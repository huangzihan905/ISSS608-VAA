[
  {
    "objectID": "VAST Challenge 2025/MC1/MC1.html",
    "href": "VAST Challenge 2025/MC1/MC1.html",
    "title": "MC1",
    "section": "",
    "text": "pacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph)\nkg&lt;-fromJSON(\"MC1_release/MC1_graph.json\")"
  },
  {
    "objectID": "VAST Challenge 2025/MC1/MC1.html#creating-knowledge-graph",
    "href": "VAST Challenge 2025/MC1/MC1.html#creating-knowledge-graph",
    "title": "MC1",
    "section": "Creating Knowledge Graph",
    "text": "Creating Knowledge Graph\n\nStep 1: Mapping from node id to row index\n\nid_map &lt;- tibble (id = nodes_tbl$id,\n                  index = seq_len(\n                    nrow(nodes_tbl)\n                  ))\n\nThis ensures each id from your node list is mapped to the correct row number\n\n\nStep 2: Map source and traget IDs to row indices\n\nedges_tbl&lt;-edges_tbl %&gt;%\n  left_join(id_map, by = c(\"source\" = \"id\")) %&gt;%\n  rename (from = index) %&gt;%\n  left_join(id_map, by = c(\"target\"=\"id\")) %&gt;%\n  rename(to = index)\n\n\n\nStep 3: Filter out any unmatched (invalid) edges\n\nedges_tbl&lt;-edges_tbl %&gt;%\n  filter(!is.na(from),!is.na(to))\n\n\n\nStep 4: Creating the graph\ntbl_graph() is used to create tidygraph’s graph pbject by using the code chunk below.\n\ngraph&lt;-tbl_graph(nodes = nodes_tbl,\n                 edges = edges_tbl,\n                 directed = kg$directed)"
  },
  {
    "objectID": "VAST Challenge 2025/MC1/MC1.html#visualizing-the-knowledge-graph",
    "href": "VAST Challenge 2025/MC1/MC1.html#visualizing-the-knowledge-graph",
    "title": "MC1",
    "section": "Visualizing the knowledge graph",
    "text": "Visualizing the knowledge graph\n\nset.seed(1234)\n\n\nVisualizing the whole graph\n\nggraph(graph, layout = \"fr\")+\n  geom_edge_link(alpha = 0.3, colour =\"gray\")+\n  geom_node_point(aes(color = `Node Type`),\n                  size = 4)+\n  geom_node_text(aes(label=name),\n                 repel = TRUE,\n                 size =2.5)+\n  theme_void()\n\n\n\nVisualizing sub-graph\n\nStep 1: Filter edges to only “Memberof”\n\ngraph_memberof&lt;-graph %&gt;%\n  activate(edges) %&gt;%\n  filter(`Edge Type`==\"MemberOf\")\n\n\n\nStep 2: Extract only connected nodes (i.e., used in these edges)\n\nused_node_indices &lt;- graph_memberof %&gt;%\n  activate(edges) %&gt;%\n  as_tibble() %&gt;%\n  select(from,to) %&gt;%\n  unlist() %&gt;%\n  unique()\n\n\n\nStep 3: Keep only those nodes\n\ngraph_memberof &lt;- graph_memberof %&gt;%\n  activate(nodes) %&gt;%\n  mutate(row_id = row_number()) %&gt;%\n  filter(row_id %in% used_node_indices) %&gt;%\n  select(-row_id)\n\n\n\nPlot the sub-graph\n\nggraph(graph_memberof,\n       layout = \"fr\")+\n  geom_edge_link(alpha = 0.5,\n                 colour = \"gray\")+\n  geom_node_point(aes(color=`Node Type`),\n                  size = 1)+\n  geom_node_text(aes(label = name),\n                 repel=TRUE,\n                 size=2.5)+\n  theme_void()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html",
    "title": "Take-home Exercise 3",
    "section": "",
    "text": "In this take-home exercise, we are required to select one of the module of our proposed Shiny application and complete the following tasks:\n\nTo evaluate and determine the necessary R packages needed for your Shiny application are supported in R CRAN,\nTo prepare and test the specific R codes can be run and returned the correct output as expected,\nTo determine the parameters and outputs that will be exposed on the Shiny applications, and\nTo select the appropriate Shiny UI components for exposing the parameters determine above."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#loading-r-packages",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#loading-r-packages",
    "title": "Take-home Exercise 3",
    "section": "3.1 Loading R Packages",
    "text": "3.1 Loading R Packages\nThe following packages are the needed packages:\n\ntidyverse: A collection of R packages designed for data science, offering tools for data manipulation, visualization, and analysis using a consistent syntax.\njsonlite: Provides a robust and easy-to-use framework for parsing and generating JSON data in R.\nSmartEDA: Automates exploratory data analysis (EDA) by generating summary statistics, visualizations, and variable profiling with minimal code.\ntidygraph: Brings tidyverse principles to graph data, enabling tidy manipulation of nodes and edges in network analysis.\nggraph: An extension of ggplot2 for visualizing graph and network structures in a customizable and aesthetically pleasing way.\nplotly: Enables interactive, web-based visualizations using ggplot2 or direct plotly syntax, enhancing data exploration.\ntreemapify: Creates treemaps using the ggplot2 framework, allowing hierarchical data to be visualized with area-proportional rectangles.\nvisNetwork: Facilitates interactive network visualization using the vis.js JavaScript library, enabling dynamic manipulation and exploration of network graphs.\nRColorBrewer: An R package that provides a selection of color palettes specially designed for creating clear, visually appealing maps and graphics, particularly for categorical and sequential data.\nDT: Enables the creation of interactive data tables with features like sorting, filtering, and pagination, ideal for Shiny applications or HTML outputs.\n\n\n\nggthemes: Provides additional themes and styles for ggplot2, allowing for quick customization of chart aesthetics to enhance readability.\n\n\n\nShow the code\npacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph, plotly, treemapify, visNetwork, RColorBrewer, DT, ggthemes)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#importing-the-data",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#importing-the-data",
    "title": "Take-home Exercise 3",
    "section": "3.2 Importing the Data",
    "text": "3.2 Importing the Data\nFor the purpose of this exercise, MC1_graph.json file will be used. Before getting started, we should have the data set in the data sub-folder.\nIn the code chunk below, fromJSON() of jsonlite package is used to import MC1_graph.json file into R and save the output object\n\n\nShow the code\nkg &lt;- fromJSON(\"MC1_release/MC1_graph.json\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#extracting-nodes-and-edges",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#extracting-nodes-and-edges",
    "title": "Take-home Exercise 3",
    "section": "4.1 Extracting Nodes and Edges",
    "text": "4.1 Extracting Nodes and Edges\nAfter loading the JSON file, we extract the node and edge lists:\n\n\nShow the code\nnodes_tbl &lt;- as_tibble(kg$nodes)\nedges_tbl &lt;- as_tibble(kg$links)\nglimpse(nodes_tbl)\n\n\nRows: 17,412\nColumns: 10\n$ `Node Type`    &lt;chr&gt; \"Song\", \"Person\", \"Person\", \"Person\", \"RecordLabel\", \"S…\n$ name           &lt;chr&gt; \"Breaking These Chains\", \"Carlos Duffy\", \"Min Qin\", \"Xi…\n$ single         &lt;lgl&gt; TRUE, NA, NA, NA, NA, FALSE, NA, NA, NA, NA, TRUE, NA, …\n$ release_date   &lt;chr&gt; \"2017\", NA, NA, NA, NA, \"2026\", NA, NA, NA, NA, \"2020\",…\n$ genre          &lt;chr&gt; \"Oceanus Folk\", NA, NA, NA, NA, \"Lo-Fi Electronica\", NA…\n$ notable        &lt;lgl&gt; TRUE, NA, NA, NA, NA, TRUE, NA, NA, NA, NA, TRUE, NA, N…\n$ id             &lt;int&gt; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 1…\n$ written_date   &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, \"2020\", NA, NA,…\n$ stage_name     &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ notoriety_date &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n\n\nShow the code\nglimpse(edges_tbl)\n\n\nRows: 37,857\nColumns: 4\n$ `Edge Type` &lt;chr&gt; \"InterpolatesFrom\", \"RecordedBy\", \"PerformerOf\", \"Composer…\n$ source      &lt;int&gt; 0, 0, 1, 1, 2, 2, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5…\n$ target      &lt;int&gt; 1841, 4, 0, 16180, 0, 16180, 0, 5088, 14332, 11677, 2479, …\n$ key         &lt;int&gt; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0…"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#map-node-ids-to-row-indices",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#map-node-ids-to-row-indices",
    "title": "Take-home Exercise 3",
    "section": "4.2 Map Node IDs to Row Indices",
    "text": "4.2 Map Node IDs to Row Indices\nSince tidygraph relies on row numbers (not raw IDs) for defining connections between nodes, we generate a mapping from each node’s unique id to its corresponding row index:\n\n\nShow the code\nid_map &lt;- tibble(id = nodes_tbl$id,\n                 index = seq_len(nrow(nodes_tbl)))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#replace-edge-ids-with-row-indices",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#replace-edge-ids-with-row-indices",
    "title": "Take-home Exercise 3",
    "section": "4.3 Replace Edge IDs with Row Indices",
    "text": "4.3 Replace Edge IDs with Row Indices\nWe then update the edges_tbl by replacing the source and target IDs with the corresponding row indices (from, to) using two left_join() operations:\n\n\nShow the code\nedges_tbl &lt;- edges_tbl %&gt;%\n  left_join(id_map, by = c(\"source\" = \"id\")) %&gt;%\n  rename(from = index) %&gt;%\n  left_join(id_map, by = c(\"target\" = \"id\")) %&gt;%\n  rename(to = index)\n\n\nThis step aligns the edge table with the row-based referencing system used by tidygraph."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#filter-invalid-edges",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#filter-invalid-edges",
    "title": "Take-home Exercise 3",
    "section": "4.4 Filter Invalid Edges",
    "text": "4.4 Filter Invalid Edges\nSome edges might refer to nodes that don’t exist (e.g., due to missing or inconsistent IDs). These would result in NA values in the from or to columns. We filter out such cases to ensure the integrity of the graph:\n\n\nShow the code\nedges_tbl &lt;- edges_tbl %&gt;%\n  filter(!is.na(from), !is.na(to))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#subset-relevant-songs-oceanus-folk-sailor-shift",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#subset-relevant-songs-oceanus-folk-sailor-shift",
    "title": "Take-home Exercise 3",
    "section": "4.5 Subset Relevant Songs (Oceanus Folk & Sailor Shift)",
    "text": "4.5 Subset Relevant Songs (Oceanus Folk & Sailor Shift)\nIn this assignment, since we need to analyze the relationship between Oceanus Folk and Salior Shift, we prepared the data subset here.\nOceanus Folk songs:\n\n\nShow the code\nof_songs &lt;- nodes_tbl %&gt;%\n  filter(`Node Type` == \"Song\", genre == \"Oceanus Folk\")\n\n\nSailor Shift songs:\n\n\nShow the code\n# Get Sailor Shift's person id\nsailor_shift_id &lt;- nodes_tbl %&gt;%\n  filter(`Node Type` == \"Person\", name == \"Sailor Shift\") %&gt;%\n  pull(id)\n\n# Get All Songs Performed by Sailor Shift\nss_song_ids &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", source == sailor_shift_id) %&gt;%\n  pull(target)\n\n# Get Song Details\nsailor_shift_songs &lt;- nodes_tbl %&gt;%\n  filter(id %in% ss_song_ids, `Node Type` == \"Song\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#define-influence-operationally",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#define-influence-operationally",
    "title": "Take-home Exercise 3",
    "section": "4.6 Define “influence” operationally",
    "text": "4.6 Define “influence” operationally\nTo illustrate how the influence of Oceanus Folk has spread through the musical world, we need to define “influence” first.\nA song is influenced by Oceanus Folk if:\n\nThe source is an Oceanus Folk song\nThe edge type is one of the below\nThe target is any other node (usually a song or album)\n\nBased on these points, we can get the influence-type edges by the following code chunk:\n\n\nShow the code\ninfluence_types &lt;- c(\"InStyleOf\", \"CoverOf\", \"LyricalReferenceTo\", \"InterpolatesFrom\", \"DirectlySamples\")\n\ninfluence_edges &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` %in% influence_types)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#outward-influence-of-oceanus-folks",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#outward-influence-of-oceanus-folks",
    "title": "Take-home Exercise 3",
    "section": "4.7 OUTWARD Influence of Oceanus Folks",
    "text": "4.7 OUTWARD Influence of Oceanus Folks\nSongs or albums influenced by Oceanus Folk:\n\n\nShow the code\n# Get IDs of Oceanus Folk songs\nof_song_ids &lt;- of_songs$id\n\n# Filter edges where Oceanus Folk is the influencer (source)\noutward_influences &lt;- influence_edges %&gt;%\n  filter(source %in% of_song_ids)\n\n# Get target nodes that were influenced by Oceanus Folk\noutward_nodes &lt;- nodes_tbl %&gt;%\n  filter(id %in% outward_influences$target)\n\n\nWe can now analyze outward_nodes to get genre distribution, timeline, etc."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#inward-influence-of-oceanus-folks",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#inward-influence-of-oceanus-folks",
    "title": "Take-home Exercise 3",
    "section": "4.8 INWARD Influence of Oceanus Folks",
    "text": "4.8 INWARD Influence of Oceanus Folks\nSongs or albums that influenced Oceanus Folk:\n\n\nShow the code\n# Get IDs of Oceanus Folk songs\nof_song_ids &lt;- of_songs$id\n\n# Filter edges where Oceanus Folk songs are the influenced target\ninward_influences &lt;- influence_edges %&gt;%\n  filter(target %in% of_song_ids)\n\n# Get source nodes that influenced Oceanus Folk songs\ninward_nodes &lt;- nodes_tbl %&gt;%\n  filter(id %in% inward_influences$source)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#count-of-edge-types",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#count-of-edge-types",
    "title": "Take-home Exercise 3",
    "section": "5.1 Count of Edge Types",
    "text": "5.1 Count of Edge Types\nTo better understand the types of relationships captured in our influence network, we visualized the distribution of edge types—which represent different kinds of connections between musical entities such as songs, artists, genres, and albums.\n\n\nShow the code\nggplot(data = edges_tbl,\n       aes(y=`Edge Type`))+\n  geom_bar()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#count-of-node-types",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#count-of-node-types",
    "title": "Take-home Exercise 3",
    "section": "5.2 Count of Node Types",
    "text": "5.2 Count of Node Types\nTo gain a deeper understanding of the network structure, we examined the composition of node types within the influence network. Each node represents a distinct entity—such as an artist, song, album, or genre—and its type defines its role in the broader network.\n\n\nShow the code\nggplot(data = nodes_tbl,\n       aes(y=`Node Type`))+\n  geom_bar()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#genre-distribution-of-songs",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#genre-distribution-of-songs",
    "title": "Take-home Exercise 3",
    "section": "5.3 Genre Distribution of Songs",
    "text": "5.3 Genre Distribution of Songs\nTo explore the musical diversity within the network, we analyzed the genre distribution of songs. This reveals which musical styles are most represented among the works connected to or influenced by Oceanus Folk.\n\n\nShow the code\nnodes_tbl %&gt;%\n  filter(`Node Type` == \"Song\") %&gt;%\n  count(genre, sort = TRUE) %&gt;%\n  ggplot(aes(x = reorder(genre, n), y = n)) +\n  geom_bar(stat = \"identity\", fill = \"tomato\") +\n  coord_flip() +\n  labs(title = \"Count of Songs in each Genre\", x = \"Genre\", y = \"Count\") +\n  theme_minimal()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#temporal-distribution-of-oceanus-folk-songs",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#temporal-distribution-of-oceanus-folk-songs",
    "title": "Take-home Exercise 3",
    "section": "5.4 Temporal Distribution of Oceanus Folk Songs",
    "text": "5.4 Temporal Distribution of Oceanus Folk Songs\nTo understand the evolution of Oceanus Folk over time, we examined the release trend of songs classified under this genre. This analysis provides insight into when Oceanus Folk was most actively produced and possibly most influential.\n\n\nShow the code\nof_songs %&gt;%\n  filter(!is.na(release_date)) %&gt;%\n  count(release_date) %&gt;%\n  ggplot(aes(x = as.integer(release_date), y = n)) +\n  geom_line(color = \"purple\") +\n  labs(title = \"Release Trend of Oceanus Folk Songs\", x = \"Year\", y = \"Number of Songs\") +\n  theme_minimal()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#influenced-genre-distribution",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#influenced-genre-distribution",
    "title": "Take-home Exercise 3",
    "section": "5.5 Influenced Genre Distribution",
    "text": "5.5 Influenced Genre Distribution\nTo assess the reach and stylistic impact of Oceanus Folk, we analyzed the genres of songs that have been influenced by it. This allows us to understand how Oceanus Folk has contributed to shaping other musical styles across the network.\n\n\nShow the code\noutward_nodes %&gt;%\n  count(genre, sort = TRUE) %&gt;%\n  ggplot(aes(x = reorder(genre, n), y = n)) +\n  geom_bar(stat = \"identity\", fill = \"skyblue\") +\n  coord_flip() +\n  labs(title = \"Top 10 Genres Influenced by Oceanus Folk\", x = \"Genre\", y = \"Count\") +\n  theme_minimal()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#temporal-spread-of-influence-from-oceanus-folk",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#temporal-spread-of-influence-from-oceanus-folk",
    "title": "Take-home Exercise 3",
    "section": "6.1 Temporal Spread of Influence from Oceanus Folk",
    "text": "6.1 Temporal Spread of Influence from Oceanus Folk\nThe visualization shows that Oceanus Folk had minimal influence before the year 2000, with only sporadic instances of influenced songs. However, starting in the mid-2000s, there is a noticeable increase in influence, peaking dramatically around 2010 with more than 80 influenced songs in a single year. A second but smaller spike appears around 2017. Following that, the influence seems to decline gradually, with some fluctuations, suggesting that the genre’s impact, while still present, has become more subdued in last years.\n\n\nShow the code\n# Step 1: Get influenced songs from Oceanus Folk\ninfluence_over_time &lt;- influence_edges %&gt;%\n  filter(source %in% of_songs$id) %&gt;%\n  left_join(nodes_tbl, by = c(\"target\" = \"id\")) %&gt;%\n  filter(`Node Type` == \"Song\", !is.na(release_date)) %&gt;%\n  mutate(release_year = as.integer(release_date)) %&gt;%\n  count(release_year, name = \"influenced_count\")\n\n# Step 2: Create interactive time series plot\nplot_ly(influence_over_time,\n        x = ~release_year,\n        y = ~influenced_count,\n        type = 'scatter',\n        mode = 'lines+markers',\n        line = list(color = 'steelblue'),\n        marker = list(size = 6, color = 'black'),\n        text = ~paste(\"Year:\", release_year, \"&lt;br&gt;Influenced Songs:\", influenced_count),\n        hoverinfo = 'text') %&gt;%\n  layout(title = \"Spread of Oceanus Folk Influence Over Time\",\n         xaxis = list(title = \"Release Year of Influenced Songs\"),\n         yaxis = list(title = \"Number of Influenced Songs\"),\n         hoverlabel = list(bgcolor = \"white\"))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#heatmap-of-oceanus-folk-influence-by-genre-and-year",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#heatmap-of-oceanus-folk-influence-by-genre-and-year",
    "title": "Take-home Exercise 3",
    "section": "6.2 Heatmap of Oceanus Folk Influence by Genre and Year",
    "text": "6.2 Heatmap of Oceanus Folk Influence by Genre and Year\nTo further explore the diffusion of Oceanus Folk influence across time and genre, we visualize a heatmap where each cell corresponds to the number of influenced songs in a specific genre and year. The darker the shade, the stronger the influence. This approach highlights not just volume but also temporal patterns in genre-specific influence.\n\n\nShow the code\n# Prepare tooltip text\ninfluence_heatmap &lt;- influence_edges %&gt;%\n  filter(source %in% of_songs$id) %&gt;%\n  left_join(nodes_tbl, by = c(\"target\" = \"id\")) %&gt;%\n  filter(!is.na(release_date), !is.na(genre)) %&gt;%\n  count(release_date, genre) %&gt;%\n  mutate(release_year = as.character(release_date),  # Treat as categorical\n         tooltip = paste(\"&lt;b&gt;\", release_year, \"&lt;/b&gt;\", \n                         \"\\nGenre : \", genre,\n                         \"\\nInfluenced Songs : \", n))\n\n# Heatmap plot using ggplot and theme_tufte\nheat &lt;- ggplot(influence_heatmap, aes(x = release_year, y = genre, fill = n)) + \n  geom_tile(color = \"white\", size = 1, aes(text = tooltip)) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"Influenced Songs\", low = \"#fff2f4\", high = \"coral\") +\n  labs(x = \"Release Year\", \n       y = \"Genre\", \n       title = \"Oceanus Folk Influence by Genre and Year\",\n       caption = \"Data Source: VAST Challenge 2025 MC1\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 8, angle = 90, hjust = 1),\n        axis.text.y = element_text(size = 8),\n        plot.title = element_text(hjust = 0.5, face = \"bold\"),\n        legend.title = element_text(size = 9),\n        legend.text = element_text(size = 7),\n        legend.position = \"top\")\n\n# Convert to interactive plot\nggplotly(heat, tooltip = \"text\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#descriptive-statstics-of-artists-influenced-by-oceanus-folk",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#descriptive-statstics-of-artists-influenced-by-oceanus-folk",
    "title": "Take-home Exercise 3",
    "section": "7.1 Descriptive Statstics of Artists Influenced by Oceanus Folk",
    "text": "7.1 Descriptive Statstics of Artists Influenced by Oceanus Folk\nTo explore the downstream impact of Oceanus Folk, we compiled detailed information about songs that were influenced by the genre and the artists who performed them. This allows us to understand the breadth of influence across both individual creators and musical styles.\nThe process involved several steps:\n\nStep 1: Identifying songs directly influenced by Oceanus Folk, based on network edge relationships.\nStep 2: Extracting the performing artists linked to those songs through \"PerformerOf\" edges.\nStep 3: Merging song metadata (e.g., genre, release year, notable status) with artist information.\nStep 4: Displaying the results in an interactive data table for further exploration.\n\n\n\nShow the code\n# Step 1: Get songs influenced by Oceanus Folk\nof_influenced_songs &lt;- influence_edges %&gt;%\n  filter(source %in% of_songs$id) %&gt;%\n  left_join(nodes_tbl, by = c(\"target\" = \"id\")) %&gt;%\n  filter(`Node Type` == \"Song\") %&gt;%\n  rename(song_id = target, \n         song_name = name)\n\n# Step 2: Get performing artist IDs and names\nperformers &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", target %in% of_influenced_songs$song_id) %&gt;%\n  rename(song_id = target, artist_id = source) %&gt;%\n  left_join(nodes_tbl, by = c(\"artist_id\" = \"id\")) %&gt;%\n  select(song_id, artist_id, artist_name = name)\n\n# Step 3: Combine song info and artist info\ninfluenced_song_details &lt;- of_influenced_songs %&gt;%\n  left_join(performers, by = \"song_id\") %&gt;%\n  select(song_id,\n         song_name,\n         artist_id,\n         artist_name,\n         genre,\n         release_date,\n         notoriety_date,\n         notable,\n         single)\n\n# Step 4: Show interactive data table\nDT::datatable(\n  influenced_song_details,\n  options = list(\n    pageLength = 10,\n    autoWidth = TRUE,\n    scrollX = TRUE\n  ),\n  rownames = FALSE,\n  caption = htmltools::tags$caption(\n    style = \"caption-side: top; text-align: left;\",\n    \"Table: Songs influenced by Oceanus Folk and their performing artists\"\n  )\n)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#most-influenced-artists-by-oceanus-folk",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#most-influenced-artists-by-oceanus-folk",
    "title": "Take-home Exercise 3",
    "section": "7.2 Most influenced artists by Oceanus Folk",
    "text": "7.2 Most influenced artists by Oceanus Folk\nThis bar chart highlights the individual artists most influenced by the genre. Each bar represents an artist, with the length corresponding to the number of songs they performed that were influenced by Oceanus Folk. The chart reveals that five artists, Synaptic Stream, Stephen Meyer, Fixx’d, Chao Tan, and Alfred Thibault, are the most prominently influenced, each associated with three influenced songs. A substantial number of other artists follow closely, each contributing two influenced works.\n\n\nShow the code\n# Step 1: Get songs influenced by Oceanus Folk\nof_influenced_song_ids &lt;- influence_edges %&gt;%\n  filter(source %in% of_songs$id) %&gt;%\n  pull(target)\n\n# Step 2: Link to PerformerOf edges\ntop_artist_ids &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", target %in% of_influenced_song_ids) %&gt;%\n  count(source, sort = TRUE) %&gt;%\n  slice_max(n, n = 10)\n\n# Step 3: Get artist names\ntop_artists &lt;- top_artist_ids %&gt;%\n  left_join(nodes_tbl, by = c(\"source\" = \"id\"))\n\n# Step 4: Plot with improved theme\nggplot(top_artists, aes(x = reorder(name, n), y = n)) +\n  geom_col(fill = \"lightcoral\") +\n  geom_text(aes(label = n), hjust = -0.2, size = 3, family = \"Helvetica\") +\n  coord_flip() +\n  labs(\n    title = \"Top Artists Influenced by Oceanus Folk\",\n    x = \"Artist\",\n    y = \"Number of Influenced Songs\"\n  ) +\n  theme_tufte(base_family = \"Helvetica\") +\n  theme(\n    plot.title = element_text(hjust = 0.5, face = \"bold\"),\n    axis.text.x = element_text(size = 8),\n    axis.text.y = element_text(size = 8),\n    axis.title.x = element_text(size = 9),\n    axis.title.y = element_text(size = 9)\n  )"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#network-analysis",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#network-analysis",
    "title": "Take-home Exercise 3",
    "section": "7.3 Network Analysis",
    "text": "7.3 Network Analysis\n\n7.3.1 Network Analysis for Genres Influenced by Oceanus Folk\nUsing a 1-hop ego network, we visualized how Oceanus Folk connects to other genres via influence relationships. In this graph, Oceanus Folk is at the center, with directed edges pointing to genres of influenced songs.\nThe size and color of each node correspond to influence strength, revealing that genres such as Dream Pop, Indie Folk, and Experimental Pop are among the top five most influenced. This diagram emphasizes Oceanus Folk’s cross-genre impact, showing how its core attributes permeated diverse musical styles.\n\n\nShow the code\n# Step 1: Filter outward-influenced nodes to songs with known genre\noutward_genre_edges &lt;- outward_influences %&gt;%\n  left_join(nodes_tbl, by = c(\"target\" = \"id\")) %&gt;%\n  filter(`Node Type` == \"Song\", !is.na(genre)) %&gt;%\n  transmute(from = \"Oceanus Folk\", to = genre)  # Oceanus Folk → genre\n\n# Step 2: Count influence strength by genre\noutward_genre_strength &lt;- outward_genre_edges %&gt;%\n  count(to, name = \"influence_count\")\n\n# Step 3: Identify top 5 influenced genres and assign colors\ntop5_out_genres &lt;- outward_genre_strength %&gt;%\n  arrange(desc(influence_count)) %&gt;%\n  slice(1:5) %&gt;%\n  mutate(color = rev(RColorBrewer::brewer.pal(5, \"Oranges\")))\n\n# Step 4: Build nodes for visNetwork\noutward_genre_nodes &lt;- unique(c(outward_genre_edges$from, outward_genre_edges$to)) %&gt;%\n  tibble(id = .) %&gt;%\n  left_join(outward_genre_strength, by = c(\"id\" = \"to\")) %&gt;%\n  left_join(top5_out_genres %&gt;% select(id = to, top5_color = color), by = \"id\") %&gt;%\n  mutate(\n    influence_count = replace_na(influence_count, 1),\n    label = id,\n    value = influence_count * 2,\n    color = case_when(\n      id == \"Oceanus Folk\" ~ \"#4682B4\",            # Blue for Oceanus Folk\n      !is.na(top5_color) ~ top5_color,             # Top 5 in Oranges palette\n      TRUE ~ \"#FDD0A2\"                              # Others in light orange\n    ),\n    title = paste0(\"Genre: \", id, \"&lt;br&gt;Influence Count: \", influence_count)\n  )\n\n# Step 5: Render network\nvisNetwork(outward_genre_nodes, outward_genre_edges, height = \"600px\", width = \"100%\") %&gt;%\n  visEdges(arrows = \"to\") %&gt;%\n  visOptions(highlightNearest = TRUE) %&gt;%\n  visLayout(randomSeed = 456) %&gt;%\n  visPhysics(enabled = FALSE)\n\n\n\n\n\n\n\n\n7.3.2 Network Analysis for Artists Influence by Oceanus Folks\nA second ego network was constructed to map the influence from Oceanus Folk directly to artists. Each edge represents an artist who performed a song influenced by Oceanus Folk.\nThis visualization complements the earlier bar chart by offering a relational view of artistic influence, where artists are displayed as interconnected nodes rather than ranked bars. The network format allows us to visually identify clusters or outliers of influence, and the interactive layout facilitates deeper exploration of individual nodes.\n\n\nShow the code\n# Step 1: Create central node for Oceanus Folk\noceanus_ego_center_node &lt;- tibble(\n  id = \"Oceanus Folk\",\n  label = \"Oceanus Folk\",\n  group = \"genre\"\n)\n\n# Step 2: Create artist nodes only\nartist_nodes &lt;- influenced_song_details %&gt;%\n  distinct(artist_name) %&gt;%\n  filter(!is.na(artist_name)) %&gt;%\n  mutate(id = paste0(\"artist_\", row_number()),\n         label = artist_name,\n         group = \"person\")\n\n# Step 3: Create edges: Oceanus Folk → Artists (one edge per unique artist)\nedges_genre_to_artists &lt;- artist_nodes %&gt;%\n  transmute(from = \"Oceanus Folk\", to = id)\n\n# Step 4: Combine nodes and edges\nnodes_viz &lt;- bind_rows(oceanus_ego_center_node, artist_nodes)\nedges_viz &lt;- edges_genre_to_artists\n\n# Step 5: Plot network\nvisNetwork(nodes_viz, edges_viz, height = \"700px\", width = \"100%\") %&gt;%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %&gt;%\n  visLayout(randomSeed = 123) %&gt;%\n  visNodes(shape = \"dot\", size = 15) %&gt;%\n  visGroups(groupname = \"genre\", color = \"steelblue\") %&gt;%\n  visGroups(groupname = \"person\", color = \"tomato\") %&gt;%\n  visLegend()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#genres-and-artists-influence-on-oceanus-folk",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#genres-and-artists-influence-on-oceanus-folk",
    "title": "Take-home Exercise 3",
    "section": "8.1 Genres and Artists influence on Oceanus Folk",
    "text": "8.1 Genres and Artists influence on Oceanus Folk\n\n8.1.1 Network Analysis for Geners that Influence Oceanus Folks\nThis network visualization offers a perspective on how Oceanus Folk has been influenced by other musical genres, complementing earlier analyses of how Oceanus Folk spread its influence. Each node represents a genre, and the directed edges point toward Oceanus Folk, indicating that songs from these genres have influenced the development or characteristics of Oceanus Folk songs. The central red node denotes Oceanus Folk, while the surrounding blue nodes represent the genres that contributed influence.\nNode size reflects the number of influence connections from a genre into Oceanus Folk, and color intensity highlights the top 5 most influential genres, with Desert Rock, Synthpop, and Dream Pop among the most significant. The presence of diverse genres, including Symphonic Metal, Doom Metal, Speed Metal, and Jazz Surf Rock, suggests that Oceanus Folk has drawn inspiration from a wide range of styles.\n\n\nShow the code\n# Step 1: Filter inward-influencing nodes to songs with known genre\ninward_genre_edges &lt;- inward_influences %&gt;%\n  left_join(nodes_tbl, by = c(\"source\" = \"id\")) %&gt;%\n  filter(`Node Type` == \"Song\", !is.na(genre)) %&gt;%\n  transmute(from = genre, to = \"Oceanus Folk\")  # genre → Oceanus Folk\n\n# Step 2: Count influence strength by genre\ninward_genre_strength &lt;- inward_genre_edges %&gt;%\n  count(from, name = \"influence_count\")\n\n# Step 3: Identify top 5 genres and assign colors\ntop5_genres &lt;- inward_genre_strength %&gt;%\n  arrange(desc(influence_count)) %&gt;%\n  slice(1:5) %&gt;%\n  mutate(color = rev(brewer.pal(5, \"Blues\")))\n\n# Step 4: Build nodes for visNetwork\ninward_genre_nodes &lt;- unique(c(inward_genre_edges$from, inward_genre_edges$to)) %&gt;%\n  tibble(id = .) %&gt;%\n  left_join(inward_genre_strength, by = c(\"id\" = \"from\")) %&gt;%\n  left_join(top5_genres %&gt;% select(id = from, top5_color = color), by = \"id\") %&gt;%\n  mutate(\n    influence_count = replace_na(influence_count, 1),\n    label = id,\n    value = influence_count * 2,\n    color = case_when(\n      id == \"Oceanus Folk\" ~ \"#FF6347\",           # Red for Oceanus Folk\n      !is.na(top5_color) ~ top5_color,            # Top 5 in Blues palette\n      TRUE ~ \"#9ECAE1\"                             # Others light blue\n    ),\n    title = paste0(\"Genre: \", id, \"&lt;br&gt;Influence Count: \", influence_count)\n  )\n\n# Step 5: Render influence network\nvisNetwork(inward_genre_nodes, inward_genre_edges) %&gt;%\n  visEdges(arrows = \"to\") %&gt;%\n  visOptions(highlightNearest = TRUE) %&gt;%\n  visLayout(randomSeed = 321) %&gt;%\n  visPhysics(enabled = FALSE)\n\n\n\n\n\n\n\n\n8.1.2 Network Analysis for Songs, Albums and Artists that Influence Oceanus Folks\nTo complement the genre-level analysis, we examined the specific works and artists that influenced Oceanus Folk songs.\nThis multi-layer network includes:\n\nSongs and albums that directly influenced Oceanus Folk\nArtists who performed these works\nDirected edges showing influence paths from artist → work → Oceanus Folk\n\nThis visualization reveals the interpersonal and inter-work pathways through which Oceanus Folk absorbed new elements. It helps us identify key contributors, understand whether albums or singles had greater impact, and explore collaborative nodes that acted as influence bridges.\n\n\nShow the code\n# Step 1: Filter influential works (songs & albums only)\ninfluential_works &lt;- inward_nodes %&gt;%\n  filter(`Node Type` %in% c(\"Song\", \"Album\")) %&gt;%\n  mutate(work_label = name,\n         work_id = paste0(\"work_\", row_number()),\n         group = ifelse(`Node Type` == \"Song\", \"song\", \"album\"))\n\n# Step 2: Get performing artists for those works\ninfluencing_artists &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", target %in% influential_works$id) %&gt;%\n  rename(work_real_id = target, artist_real_id = source) %&gt;%\n  left_join(nodes_tbl, by = c(\"artist_real_id\" = \"id\")) %&gt;%\n  filter(`Node Type` == \"Person\") %&gt;%\n  distinct(artist_real_id, name) %&gt;%\n  mutate(artist_label = name,\n         artist_id = paste0(\"artist_\", row_number()),\n         group = \"person\")\n\n# Step 3: Build node list\n# Central node: Oceanus Folk\ncenter_node &lt;- tibble(\n  id = \"Oceanus Folk\",\n  label = \"Oceanus Folk\",\n  group = \"center\"\n)\n\n# Work nodes\nwork_nodes &lt;- influential_works %&gt;%\n  select(id = work_id, label = work_label, group)\n\n# Artist nodes\nartist_nodes &lt;- influencing_artists %&gt;%\n  select(id = artist_id, label = artist_label, group)\n\nnodes_viz &lt;- bind_rows(center_node, work_nodes, artist_nodes)\n\n# Step 4: Create edges\n# Works → Oceanus Folk\nedges_to_of &lt;- influential_works %&gt;%\n  transmute(from = work_id, to = \"Oceanus Folk\")\n\n# Artists → Works\nedges_artist_to_work &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", target %in% influential_works$id) %&gt;%\n  rename(work_real_id = target, artist_real_id = source) %&gt;%\n  left_join(influential_works, by = c(\"work_real_id\" = \"id\")) %&gt;%\n  left_join(influencing_artists, by = c(\"artist_real_id\")) %&gt;%\n  transmute(from = artist_id, to = work_id) %&gt;%\n  filter(!is.na(from), !is.na(to))\n\nedges_viz &lt;- bind_rows(edges_artist_to_work, edges_to_of)\n\n# Step 5: Visualize\nvisNetwork(nodes_viz, edges_viz, height = \"700px\", width = \"100%\") %&gt;%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %&gt;%\n  visLayout(randomSeed = 999) %&gt;%\n  visNodes(shape = \"dot\", size = 15) %&gt;%\n  visGroups(groupname = \"center\", color = \"tomato\") %&gt;%\n  visGroups(groupname = \"song\", color = \"lightblue\") %&gt;%\n  visGroups(groupname = \"album\", color = \"khaki\") %&gt;%\n  visGroups(groupname = \"person\", color = \"orchid\") %&gt;%\n  visLegend()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#sailor-shift-influence-on-oceanus-folk",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#sailor-shift-influence-on-oceanus-folk",
    "title": "Take-home Exercise 3",
    "section": "8.2 Sailor Shift influence on Oceanus Folk",
    "text": "8.2 Sailor Shift influence on Oceanus Folk\nTo analyze how Sailor Shift influenced Oceanus Folk, we need to explore both:\n\nDirect influence: Did any Sailor Shift songs directly influence Oceanus Folk songs?\nIndirect influence Did Sailor Shift influence intermediary songs that later influenced Oceanus Folk?\n\n\n8.2.1 Checking Direct Influence\nWe first identified works directly influenced by Sailor Shift’s songs, and the artists who performed them. While the analysis did not uncover many direct connections to Oceanus Folk songs, we visualized the network of Sailor Shift → influenced works → performing artists.\nThis clarified Sailor Shift’s general influence sphere—setting the stage for evaluating whether these intermediaries played a role in influencing Oceanus Folk downstream.\n\nDescriptive Statstics of Artists Influenced by Salior Shift Songs\n\n\n\nShow the code\n# Step 2: Get influence edges where Sailor Shift's songs are the source\nss_song_ids &lt;- sailor_shift_songs$id\n\nss_outward_edges &lt;- influence_edges %&gt;%\n  filter(source %in% ss_song_ids)\n\n# Step 3: Get the target works (songs or albums) influenced by Sailor Shift\ninfluenced_works &lt;- nodes_tbl %&gt;%\n  filter(id %in% ss_outward_edges$target)\n\n# Step 4: Get artists who performed these influenced works\ninfluenced_artist_links &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", target %in% influenced_works$id) %&gt;%\n  rename(work_id = target, artist_id = source) %&gt;%\n  left_join(nodes_tbl, by = c(\"artist_id\" = \"id\")) %&gt;%\n  select(work_id, artist_id, artist_name = name)\n\n# Step 5: Join with work metadata for descriptive view\ninfluenced_by_sailor &lt;- influenced_works %&gt;%\n  left_join(influenced_artist_links, by = c(\"id\" = \"work_id\")) %&gt;%\n  select(work_id = id,\n         work_name = name,\n         work_type = `Node Type`,\n         artist_id,\n         artist_name,\n         genre,\n         release_date,\n         notable)\n\n# Step 6: Show interactive data table\nDT::datatable(\n  influenced_by_sailor,\n  options = list(\n    pageLength = 10,\n    autoWidth = TRUE,\n    scrollX = TRUE\n  ),\n  rownames = FALSE,\n  caption = htmltools::tags$caption(\n    style = \"caption-side: top; text-align: left;\",\n    \"Table: Songs influenced by Salior Shift and their performing artists\"\n  )\n)\n\n\n\n\n\n\n\nNetwork Analysis for Works and Artists influenced by Salior Shift\n\n\n\nShow the code\n# Step 1: Create center node for Sailor Shift\nss_center_node &lt;- tibble(\n  id = \"Sailor Shift\",\n  label = \"Sailor Shift\",\n  group = \"center\"\n)\n\n# Step 2: Create work nodes (distinguish between songs and albums using group)\nwork_nodes &lt;- influenced_by_sailor %&gt;%\n  distinct(work_name, work_type) %&gt;%\n  mutate(id = paste0(\"work_\", row_number()),\n         label = work_name,\n         group = ifelse(work_type == \"Song\", \"song\", \"album\"))\n\n# Step 3: Create artist nodes\nartist_nodes &lt;- influenced_by_sailor %&gt;%\n  distinct(artist_name) %&gt;%\n  filter(!is.na(artist_name)) %&gt;%\n  mutate(id = paste0(\"artist_\", row_number()),\n         label = artist_name,\n         group = \"person\")\n\n# Step 4: Create edges from Sailor Shift → Works\nedges_ss_to_works &lt;- work_nodes %&gt;%\n  transmute(from = \"Sailor Shift\", to = id)\n\n# Step 5: Create edges from Works → Artists\nedges_work_to_artist &lt;- influenced_by_sailor %&gt;%\n  inner_join(work_nodes, by = c(\"work_name\" = \"label\")) %&gt;%\n  inner_join(artist_nodes, by = c(\"artist_name\" = \"label\")) %&gt;%\n  transmute(from = id.x, to = id.y)\n\n# Step 6: Combine nodes and edges\nnodes_viz &lt;- bind_rows(ss_center_node, work_nodes, artist_nodes)\nedges_viz &lt;- bind_rows(edges_ss_to_works, edges_work_to_artist)\n\n# Step 7: Visualize\nvisNetwork(nodes_viz, edges_viz, height = \"700px\", width = \"100%\") %&gt;%\n  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %&gt;%\n  visLayout(randomSeed = 888) %&gt;%\n  visNodes(shape = \"dot\", size = 15) %&gt;%\n  visGroups(groupname = \"center\", color = \"steelblue\") %&gt;%\n  visGroups(groupname = \"song\", color = \"lightgreen\") %&gt;%\n  visGroups(groupname = \"album\", color = \"khaki\") %&gt;%\n  visGroups(groupname = \"person\", color = \"tomato\") %&gt;%\n  visLegend()\n\n\n\n\n\n\n\n\n8.2.2 Checking Indirect Influence\n\nDescriptive Statistics of Artists Who Influenced Sailor Shift Songs\n\nThe following code chunk is to check if Sailor Shift has the indirect influence on Oceanus Folk. The return result is 2, which means there are two influence.\n\n\nShow the code\n# Step 1: Get direct influence targets from Sailor Shift's songs\nss_to_others &lt;- influence_edges %&gt;%\n  filter(source %in% ss_song_ids) %&gt;%\n  select(source_ss = source, intermediary = target)\n\n# Step 2: Get targets that influenced Oceanus Folk songs\nothers_to_of &lt;- influence_edges %&gt;%\n  filter(source %in% ss_to_others$intermediary,\n         target %in% of_song_ids) %&gt;%\n  select(intermediary = source, of_song = target)\n\n# Step 3: Join the two to find indirect influence paths\nindirect_path &lt;- ss_to_others %&gt;%\n  inner_join(others_to_of, by = \"intermediary\")\n\n# Output the number of indirect influence paths\nnrow(indirect_path)\n\n\n[1] 2\n\n\n\nNetwork Analysis for Works and Artists Who Influenced Sailor Shift\n\nThis visualization illustrates an indirect influence path showing how Sailor Shift’s music may have shaped other works within the Oceanus Folk genre through an intermediary. Starting with “Saltwater Hymn”, a song performed by Sailor Shift and categorized under Oceanus Folk, the influence flows to “Parallel Memories”, a Dream Pop song by Tao Wen. This intermediary song then influences two other Oceanus Folk songs: “Grip and Grace” by Jun Xu and “Aquatic Rebirth (1983)” by Donald Medina.\nAlthough Sailor Shift did not directly influence these two final songs, the network reveals a two-step chain of influence, suggesting that their artistic style or thematic elements may have propagated indirectly through another genre and artist.\n\n\nShow the code\n# Step 1: Map PerformerOf edges to get artist names for songs\nsong_artists &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\") %&gt;%\n  select(song_id = target, artist_id = source) %&gt;%\n  left_join(\n    nodes_tbl %&gt;%\n      filter(`Node Type` == \"Person\") %&gt;%\n      select(artist_id = id, artist_name = name),\n    by = \"artist_id\"\n  )\n\n# Step 2: Prepare node list with genre and artist info\nindirect_nodes &lt;- nodes_tbl %&gt;%\n  filter(id %in% unique(c(indirect_path$source_ss, indirect_path$intermediary, indirect_path$of_song))) %&gt;%\n  left_join(song_artists, by = c(\"id\" = \"song_id\")) %&gt;%\n  mutate(\n    genre = ifelse(is.na(genre), \"Unknown Genre\", genre),\n    artist_name = ifelse(is.na(artist_name), \"Unknown Artist\", artist_name),\n    label = paste0(name, \"\\n\", genre, \" - \", artist_name),\n    title = paste0(\"Song: \", name, \"&lt;br&gt;Genre: \", genre, \"&lt;br&gt;Artist: \", artist_name)\n  ) %&gt;%\n  select(id, label, title) %&gt;%\n  distinct(id, .keep_all = TRUE)  # Ensure no duplicate node IDs\n\n# Step 3: Create the combined_edges object\nedges1 &lt;- indirect_path %&gt;%\n  select(from = source_ss, to = intermediary)\n\nedges2 &lt;- indirect_path %&gt;%\n  select(from = intermediary, to = of_song)\n\ncombined_edges &lt;- bind_rows(edges1, edges2)\n\n# Step 4: Visualize the network\nvisNetwork(nodes = indirect_nodes, edges = combined_edges) %&gt;%\n  visEdges(arrows = \"to\") %&gt;%\n  visOptions(highlightNearest = TRUE) %&gt;%\n  visLayout(randomSeed = 42) %&gt;%\n  visPhysics(enabled = FALSE)\n\n\n\n\n\n\n\nComparison before and after Sailor Shift\n\nAfter examining both the direct and indirect influence paths from Sailor Shift to specific Oceanus Folk songs, it becomes evident that Sailor Shift’s impact extended beyond individual songs to influence the broader stylistic evolution of the genre. To better understand this transformation on a macro level, we now compare the overall genre influences on Oceanus Folk before and after Sailor Shift’s emergence.\nThis visualization compares the genres that influenced Oceanus Folk songs before and after the emergence of Sailor Shift, revealing a clear shift in the genre’s stylistic development. Prior to Sailor Shift, Oceanus Folk was heavily influenced by itself, as shown by the dominant blue segment representing self-influence. The total number of influences was significantly higher in this period, indicating that Oceanus Folk initially evolved through internal reinforcement and continuity within its own style.\nAfter Sailor Shift’s emergence, the number of influences decreased, but the diversity of contributing genres increased. The influence became more distributed across a broader range of genres such as Dream Pop, Doom Metal, Darkwave, and Synthpop. This suggests that while Oceanus Folk became less self-referential in the post-Sailor Shift era.\n\n\nShow the code\nss_song_ids &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", source == sailor_shift_id) %&gt;%\n  pull(target)\n\nss_release_year &lt;- nodes_tbl %&gt;%\n  filter(id %in% ss_song_ids, !is.na(release_date)) %&gt;%\n  summarise(min_year = min(as.integer(release_date))) %&gt;%\n  pull(min_year)\n\ninfluences_into_of &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` %in% influence_types,\n         target %in% of_song_ids) %&gt;%\n  left_join(nodes_tbl, by = c(\"source\" = \"id\")) %&gt;%\n  filter(`Node Type` == \"Song\", !is.na(genre), !is.na(release_date)) %&gt;%\n  mutate(release_year = as.integer(release_date),\n         period = ifelse(release_year &lt; ss_release_year, \"Before SS\", \"After SS\"))\n\ninfluences_into_of %&gt;%\n  count(period, genre) %&gt;%\n  ggplot(aes(x = period, y = n, fill = genre)) +\n  geom_col(position = \"stack\") +\n  labs(title = \"Genres Influencing Oceanus Folk\\nBefore vs. After Sailor Shift\",\n       x = \"\", y = \"Number of Influences\") +\n  theme_minimal()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#exploring-the-ripple-effect-of-oceanus-folk-in-modern-music",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03_Prototype.html#exploring-the-ripple-effect-of-oceanus-folk-in-modern-music",
    "title": "Take-home Exercise 3",
    "section": "Exploring the Ripple Effect of Oceanus Folk in Modern Music",
    "text": "Exploring the Ripple Effect of Oceanus Folk in Modern Music\nOceanus Folk, a genre rooted in emotive storytelling and maritime nostalgia, has not only evolved over time but has also left a visible mark on the broader musical ecosystem. This dashboard investigates both directions of influence: how Oceanus Folk inspired others, and how it was shaped by surrounding genres. Through temporal and network visualizations, users are invited to trace its reach and evolution.\n\nTimeline of Influence: When Oceanus Folk Made Waves\nThe first section of the dashboard focuses on Oceanus Folk’s influence on others. A line graph tracks the number of influenced songs released over time, revealing a pronounced spike around 2010—signaling a cultural resurgence or a defining moment for the genre. The accompanying data table showcases detailed metadata of influenced works, including song title, artists, genre, and key markers such as whether the track became a single or notable release. This segment combines historical and relational insight, encouraging users to explore not just the trends but also the people behind them.\n\n\n\nMapping Influences Into Oceanus Folk: A Genre Melting Pot\nThe second section flips the lens to investigate how other genres have shaped Oceanus Folk. A genre-to-genre influence network diagram places Oceanus Folk at the center of a web of arrows, connecting it with genres like Speed Metal, Dream Pop, and Americana. The visual suggests a diverse heritage and indicates stylistic blending that may have influenced Oceanus Folk’s evolution. Below that, a larger artist-work network diagram links songs and albums, distinguishing between types of musical output and highlighting central nodes with high connectivity. These visuals paint a picture of Oceanus Folk as both a cultural contributor and a genre in flux—constantly being reshaped by the music landscape around it.\n\n\n\nConclusion\nTogether, the two panels tell a comprehensive story of Oceanus Folk’s dual role in the music network:\n\nAs an influencer, Oceanus Folk peaked in cultural impact around 2010, with ripple effects continuing into the 2020s.\nAs an influenced genre, Oceanus Folk drew heavily from eclectic and contrasting genres, indicating its stylistic complexity and adaptive nature.\n\nThis dual-perspective analysis highlights Oceanus Folk’s dynamic presence—both as a creative source and a stylistic sponge—within the synthetic music ecosystem."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html",
    "title": "Take-home_Ex01",
    "section": "",
    "text": "As Singapore’s population ages rapidly, understanding demographic structures and spatial distributions is more critical than ever. The objective for this visualize analysis is to uncover meaningful patterns in the aging demographic using three visualizations: a population pyramid to show the overall age-gender distribution, a bar chart to compare elderly proportions by planning area, and a heatmap to explore age group concentrations across regions. These visualizations aim to support public awareness and inform urban planners and policymakers on how the aging population is evolving geographically and demographically.\n\n\n\n\n\n\npacman::p_load(tidyverse,dplyr, janitor)\n\n\n\n\n\n\nThe dataset used in this analysis is titled “Singapore Residents by Planning Area / Subzone, Single Year of Age and Sex, June 2024”, published by the Department of Statistics (DOS), Singapore. It provides demographic data of resident populations segmented by planning area, subzone, single year of age (from 0 to “90_and_over”), population number and sex (male and female), as of June 2024.\n\n\n\n\n\n\n\n\n\n\n\nVariable\nDefinition\nData Type\n\n\n\n\nPA\nPA means Planning Area.\nText\n\n\nSZ\nSZ means subzone. In each planning area, there are several subzones.\nText\n\n\nAge\nIn the dataset, age is the single year of age (i.e. 0, 1, 2, 3…).\nInteger\n\n\nSex\nSex includes male and female.\nText\n\n\nPop\nPop means the number of population.\nInteger\n\n\nTime\nAll the time is 2024.\nInteger\n\n\n\n\n\n\n\n\nsgresidents_2024 &lt;- read_csv(\"respopagesex2024/respopagesex2024.csv\")\nglimpse(sgresidents_2024)\n\nRows: 60,424\nColumns: 6\n$ PA   &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo K…\n$ SZ   &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang Mo Kio T…\n$ Age  &lt;chr&gt; \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", \"4\", \"4\", \"5\", \"5\", \"6\", …\n$ Sex  &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Females\", \"Male…\n$ Pop  &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, 30, 10, 3…\n$ Time &lt;dbl&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024,…\n\n\n\n\n\n\n\nThe column names in the original dataset were cleaned and standardized by using the clean_names() function from the janitor package. This step converts all column names to lowercase and replaces spaces or special characters with underscores, ensuring they are consistent and easier to reference in subsequent code.\n\nsgresidents_2024 &lt;- sgresidents_2024 %&gt;% clean_names()\n\n\n\n\nThis step filters the dataset to focus on the aging population, defined as residents aged 65 and above. Since the age column includes the value “90_and_Over” as a character string, it was first replaced with “90” to allow for numeric conversion. The age column was then converted to integer format. We filtered the dataset to retain only records where age is 65 or higher and excluded any rows with missing planning area (pa) or population (pop) values.\n\nelderly &lt;- sgresidents_2024 %&gt;%\n  \n  mutate(age = if_else(age == \"90_and_Over\", \"90\", age),\n         age = as.integer(age)) %&gt;%\n  \n  filter(age &gt;= 65, !is.na(pa), !is.na(pop))\n\n\n\n\n\n\n\n\nThe population pyramid of Singapore in 2024 illustrates a distinctly aging demographic. The population is mainly concentrated between 40 and 60 years old, which means Singapore is stepping into an aging society. The tapering base reflects a low birth rate in recent decades, with significantly fewer residents under age 20.\nThe gender split is also apparent. Female residents increasingly outnumber males in the oldest age, which can support the statement of longer female life expectancy.\nThis aging structure suggests future challenges, including rising healthcare needs, a shrinking workforce, etc. The visulization underscores the urgency for social policies to support an elderly-centric population society.\n\npyramid_data &lt;- sgresidents_2024 %&gt;%\n\n  mutate(age = if_else(age == \"90_and_Over\", \"90\", age),\n         age = as.integer(age)) %&gt;%\n  \n  filter(age &lt;= 100) %&gt;%\n  \n  group_by(age, sex) %&gt;%\n  \n  summarise(population = sum(pop), .groups = \"drop\") %&gt;%\n  \n  mutate(population = if_else(sex == \"Females\", -population, population))\n\n\nggplot(pyramid_data, aes(x = age, y = population, fill = sex)) +\n  geom_col() +\n  coord_flip() +\n  scale_y_continuous(labels = abs) +\n  labs(title = \"Population Pyramid of Singapore 2024\",\n       x = \"Age\", y = \"Population\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nThe bar chart shows the percentage of elderly residents (aged 65 and above) in each planning area of Singapore as of June 2024.\nFrom the chart, it is clear that some areas with long-established communities have a higher percentage of aging residents than others. For example, areas like Outram, Ang Mo Kio, and Bukit Merah have the highest proportions of elderly people, with more than 24% of their residents aged 65 or older.\nOn the other hand, newer or developing areas like have much lower proportions of elderly, likely because younger families are moving in and the towns are still growing.\nThis pattern shows that the aging population distribution is not evenly spread across the Singapore. These differences are important for planning healthcare, transport, and social services. For instance, older areas may need more elder care facilities, while younger areas may focus more on schools and childcare.\n\ntotal_area &lt;- sgresidents_2024 %&gt;%\n  group_by(pa) %&gt;%\n  summarise(total = sum(pop), .groups = \"drop\")\n\nelderly_area &lt;- elderly %&gt;%\n  group_by(pa) %&gt;%\n  summarise(elderly = sum(pop), .groups = \"drop\")\n\naging_ratio &lt;- left_join(total_area, elderly_area, by = \"pa\") %&gt;%\n  filter(total &gt; 0) %&gt;%\n  mutate(elderly = replace_na(elderly, 0),\n         aging_percentage = elderly / total)\n\n\nggplot(aging_ratio, aes(x = reorder(pa, aging_percentage), \n                        y = aging_percentage)) +\n  geom_col(fill = \"lightpink\") +\n  coord_flip() +\n  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +\n  labs(\n    title = \"Proportion of Elderly (65+) by Planning Area\",\n    x = \"Planning Area\",\n    y = \"Elderly Proportion\"\n  ) +\n  theme_minimal(base_size = 12) +\n    theme(axis.text.y = element_text(size = 13),\n          axis.text.x = element_text(size = 13),\n    plot.title = element_text(size = 25, face = \"bold\",\n                              hjust =0.5),\n    plot.margin = margin(10, 20, 10, 10))\n\n\n\n\n\n\n\n\n\n\n\nSince in the 3.2 section, we found that the aging distribution is not evenly spread. Therefore, in this section, the heatmap shows how the elderly population is distributed across different planning areas and age groups in Singapore.\nEach cell’s color represents the number of elderly people. Lighter cells mean more people in that age group and area. From the chart, we can see that areas like Bedok, Tampines, Hougang have the largest elderly populations, especially in the 65–74 age group.\nThis heatmap helps us understand not just where elderly people live, but also their age range. For instance, Bedok has the highest number of population which focus on 65-74 age group, which mean that it would have highest number of 85+ age group in 10 - 20 years. This forecasting can help the government prepare to support these areas.\n\nheatmap_grouped &lt;- elderly %&gt;%\n  \n  mutate(age = ifelse(age == \"90_and_Over\", \"90\", age),\n         age = as.integer(age),\n         age_group = case_when(\n           age &gt;= 65 & age &lt;= 74 ~ \"65–74\",\n           age &gt;= 75 & age &lt;= 84 ~ \"75–84\",\n           age &gt;= 85 ~ \"85+\",\n           TRUE ~ NA_character_)) %&gt;%\n  \n  filter(!is.na(age_group)) %&gt;%\n  group_by(pa, age_group) %&gt;%\n  summarise(total_pop = sum(pop), .groups = \"drop\")\n\n\nggplot(heatmap_grouped, aes(x = age_group, y = reorder(pa, -total_pop), fill = total_pop)) +\n  geom_tile(color = \"white\") +\n  scale_fill_viridis_c(option = \"C\", name = \"Population\") +\n  labs(\n    title = \"Heatmap of Elderly Population by Age Group and Planning Area\",\n    x = \"Age Group\",\n    y = \"Planning Area\"\n  ) +\n  theme_minimal(base_size = 13) +\n    theme(axis.text.y = element_text(size = 13),\n          axis.text.x = element_text(size = 15),\n    plot.title = element_text(size = 25, face = \"bold\",\n                              hjust =0.5),\n    plot.margin = margin(10, 20, 10, 10))\n\n\n\n\n\n\n\n\n\n\n\n\nThree visulization charts provide a clear picture of Singapore’s aging population and how it is distributed across planning areas.\nThe population pyramid confirms that Singapore is a rapidly aging society, with a shrinking youth base and a growing older adult population. The bar chart highlights the areas with higher elders percentage. The heatmap adds another layer of insight by showing which planning areas have the largest numbers of elderly in each age group. These findings underscore the importance of elder care infrastructures planning, and community services tailored to local aging trends across Singapore."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#overview",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#overview",
    "title": "Take-home_Ex01",
    "section": "",
    "text": "As Singapore’s population ages rapidly, understanding demographic structures and spatial distributions is more critical than ever. The objective for this visualize analysis is to uncover meaningful patterns in the aging demographic using three visualizations: a population pyramid to show the overall age-gender distribution, a bar chart to compare elderly proportions by planning area, and a heatmap to explore age group concentrations across regions. These visualizations aim to support public awareness and inform urban planners and policymakers on how the aging population is evolving geographically and demographically."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#data-preparation",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#data-preparation",
    "title": "Take-home_Ex01",
    "section": "",
    "text": "pacman::p_load(tidyverse,dplyr, janitor)\n\n\n\n\n\n\nThe dataset used in this analysis is titled “Singapore Residents by Planning Area / Subzone, Single Year of Age and Sex, June 2024”, published by the Department of Statistics (DOS), Singapore. It provides demographic data of resident populations segmented by planning area, subzone, single year of age (from 0 to “90_and_over”), population number and sex (male and female), as of June 2024.\n\n\n\n\n\n\n\n\n\n\n\nVariable\nDefinition\nData Type\n\n\n\n\nPA\nPA means Planning Area.\nText\n\n\nSZ\nSZ means subzone. In each planning area, there are several subzones.\nText\n\n\nAge\nIn the dataset, age is the single year of age (i.e. 0, 1, 2, 3…).\nInteger\n\n\nSex\nSex includes male and female.\nText\n\n\nPop\nPop means the number of population.\nInteger\n\n\nTime\nAll the time is 2024.\nInteger\n\n\n\n\n\n\n\n\nsgresidents_2024 &lt;- read_csv(\"respopagesex2024/respopagesex2024.csv\")\nglimpse(sgresidents_2024)\n\nRows: 60,424\nColumns: 6\n$ PA   &lt;chr&gt; \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo Kio\", \"Ang Mo K…\n$ SZ   &lt;chr&gt; \"Ang Mo Kio Town Centre\", \"Ang Mo Kio Town Centre\", \"Ang Mo Kio T…\n$ Age  &lt;chr&gt; \"0\", \"0\", \"1\", \"1\", \"2\", \"2\", \"3\", \"3\", \"4\", \"4\", \"5\", \"5\", \"6\", …\n$ Sex  &lt;chr&gt; \"Males\", \"Females\", \"Males\", \"Females\", \"Males\", \"Females\", \"Male…\n$ Pop  &lt;dbl&gt; 10, 10, 10, 10, 10, 10, 10, 10, 30, 10, 20, 10, 20, 30, 30, 10, 3…\n$ Time &lt;dbl&gt; 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024, 2024,…\n\n\n\n\n\n\n\nThe column names in the original dataset were cleaned and standardized by using the clean_names() function from the janitor package. This step converts all column names to lowercase and replaces spaces or special characters with underscores, ensuring they are consistent and easier to reference in subsequent code.\n\nsgresidents_2024 &lt;- sgresidents_2024 %&gt;% clean_names()\n\n\n\n\nThis step filters the dataset to focus on the aging population, defined as residents aged 65 and above. Since the age column includes the value “90_and_Over” as a character string, it was first replaced with “90” to allow for numeric conversion. The age column was then converted to integer format. We filtered the dataset to retain only records where age is 65 or higher and excluded any rows with missing planning area (pa) or population (pop) values.\n\nelderly &lt;- sgresidents_2024 %&gt;%\n  \n  mutate(age = if_else(age == \"90_and_Over\", \"90\", age),\n         age = as.integer(age)) %&gt;%\n  \n  filter(age &gt;= 65, !is.na(pa), !is.na(pop))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#visualization-charts",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#visualization-charts",
    "title": "Take-home_Ex01",
    "section": "",
    "text": "The population pyramid of Singapore in 2024 illustrates a distinctly aging demographic. The population is mainly concentrated between 40 and 60 years old, which means Singapore is stepping into an aging society. The tapering base reflects a low birth rate in recent decades, with significantly fewer residents under age 20.\nThe gender split is also apparent. Female residents increasingly outnumber males in the oldest age, which can support the statement of longer female life expectancy.\nThis aging structure suggests future challenges, including rising healthcare needs, a shrinking workforce, etc. The visulization underscores the urgency for social policies to support an elderly-centric population society.\n\npyramid_data &lt;- sgresidents_2024 %&gt;%\n\n  mutate(age = if_else(age == \"90_and_Over\", \"90\", age),\n         age = as.integer(age)) %&gt;%\n  \n  filter(age &lt;= 100) %&gt;%\n  \n  group_by(age, sex) %&gt;%\n  \n  summarise(population = sum(pop), .groups = \"drop\") %&gt;%\n  \n  mutate(population = if_else(sex == \"Females\", -population, population))\n\n\nggplot(pyramid_data, aes(x = age, y = population, fill = sex)) +\n  geom_col() +\n  coord_flip() +\n  scale_y_continuous(labels = abs) +\n  labs(title = \"Population Pyramid of Singapore 2024\",\n       x = \"Age\", y = \"Population\") +\n  theme_minimal()\n\n\n\n\n\n\n\n\n\n\n\nThe bar chart shows the percentage of elderly residents (aged 65 and above) in each planning area of Singapore as of June 2024.\nFrom the chart, it is clear that some areas with long-established communities have a higher percentage of aging residents than others. For example, areas like Outram, Ang Mo Kio, and Bukit Merah have the highest proportions of elderly people, with more than 24% of their residents aged 65 or older.\nOn the other hand, newer or developing areas like have much lower proportions of elderly, likely because younger families are moving in and the towns are still growing.\nThis pattern shows that the aging population distribution is not evenly spread across the Singapore. These differences are important for planning healthcare, transport, and social services. For instance, older areas may need more elder care facilities, while younger areas may focus more on schools and childcare.\n\ntotal_area &lt;- sgresidents_2024 %&gt;%\n  group_by(pa) %&gt;%\n  summarise(total = sum(pop), .groups = \"drop\")\n\nelderly_area &lt;- elderly %&gt;%\n  group_by(pa) %&gt;%\n  summarise(elderly = sum(pop), .groups = \"drop\")\n\naging_ratio &lt;- left_join(total_area, elderly_area, by = \"pa\") %&gt;%\n  filter(total &gt; 0) %&gt;%\n  mutate(elderly = replace_na(elderly, 0),\n         aging_percentage = elderly / total)\n\n\nggplot(aging_ratio, aes(x = reorder(pa, aging_percentage), \n                        y = aging_percentage)) +\n  geom_col(fill = \"lightpink\") +\n  coord_flip() +\n  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +\n  labs(\n    title = \"Proportion of Elderly (65+) by Planning Area\",\n    x = \"Planning Area\",\n    y = \"Elderly Proportion\"\n  ) +\n  theme_minimal(base_size = 12) +\n    theme(axis.text.y = element_text(size = 13),\n          axis.text.x = element_text(size = 13),\n    plot.title = element_text(size = 25, face = \"bold\",\n                              hjust =0.5),\n    plot.margin = margin(10, 20, 10, 10))\n\n\n\n\n\n\n\n\n\n\n\nSince in the 3.2 section, we found that the aging distribution is not evenly spread. Therefore, in this section, the heatmap shows how the elderly population is distributed across different planning areas and age groups in Singapore.\nEach cell’s color represents the number of elderly people. Lighter cells mean more people in that age group and area. From the chart, we can see that areas like Bedok, Tampines, Hougang have the largest elderly populations, especially in the 65–74 age group.\nThis heatmap helps us understand not just where elderly people live, but also their age range. For instance, Bedok has the highest number of population which focus on 65-74 age group, which mean that it would have highest number of 85+ age group in 10 - 20 years. This forecasting can help the government prepare to support these areas.\n\nheatmap_grouped &lt;- elderly %&gt;%\n  \n  mutate(age = ifelse(age == \"90_and_Over\", \"90\", age),\n         age = as.integer(age),\n         age_group = case_when(\n           age &gt;= 65 & age &lt;= 74 ~ \"65–74\",\n           age &gt;= 75 & age &lt;= 84 ~ \"75–84\",\n           age &gt;= 85 ~ \"85+\",\n           TRUE ~ NA_character_)) %&gt;%\n  \n  filter(!is.na(age_group)) %&gt;%\n  group_by(pa, age_group) %&gt;%\n  summarise(total_pop = sum(pop), .groups = \"drop\")\n\n\nggplot(heatmap_grouped, aes(x = age_group, y = reorder(pa, -total_pop), fill = total_pop)) +\n  geom_tile(color = \"white\") +\n  scale_fill_viridis_c(option = \"C\", name = \"Population\") +\n  labs(\n    title = \"Heatmap of Elderly Population by Age Group and Planning Area\",\n    x = \"Age Group\",\n    y = \"Planning Area\"\n  ) +\n  theme_minimal(base_size = 13) +\n    theme(axis.text.y = element_text(size = 13),\n          axis.text.x = element_text(size = 15),\n    plot.title = element_text(size = 25, face = \"bold\",\n                              hjust =0.5),\n    plot.margin = margin(10, 20, 10, 10))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#conclusion",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#conclusion",
    "title": "Take-home_Ex01",
    "section": "",
    "text": "Three visulization charts provide a clear picture of Singapore’s aging population and how it is distributed across planning areas.\nThe population pyramid confirms that Singapore is a rapidly aging society, with a shrinking youth base and a growing older adult population. The bar chart highlights the areas with higher elders percentage. The heatmap adds another layer of insight by showing which planning areas have the largest numbers of elderly in each age group. These findings underscore the importance of elder care infrastructures planning, and community services tailored to local aging trends across Singapore."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#original-visualization",
    "href": "Take-home_Ex/Take-home_Ex01/Take-home_Ex01.html#original-visualization",
    "title": "Take-home_Ex01",
    "section": "5 Original Visualization",
    "text": "5 Original Visualization\n\n\n\n\n\n\nJustification\n\n\n\nI chose to analyze this population pyramid because it is very similar to the first one I built for my own visualization. As I worked on mine, I was aware of the areas that could be enhanced to make the chart more understandable and informative. I discovered a few problems with my peer’s version, including some unclear labeling and potentially incorrect values, particularly with the method that the population was calculated or presented. This allowed me to think about both her and my plot and then try to make it better in my modified version.\n\n\nMy Peer’s work\n\npyramid_data &lt;- sgresidents_2024 %&gt;%\n  group_by(age, sex) %&gt;%\n  summarise(pop = sum(pop), .groups = \"drop\") %&gt;%\n  mutate(pop = ifelse(sex == \"Males\", -pop, pop))\n\nggplot(pyramid_data, aes(x = age, y = pop, fill = sex)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip() +\n  scale_y_continuous(labels = abs) +\n  scale_fill_manual(values = c(\"Males\" = \"#102E50\", \"Females\" = \"#F7CFD8\")) + \n  scale_x_discrete(breaks = seq(0, 100, by = 10)) +\n  labs(title = \"Singapore Age Pyramid (2024)\",\n       x = \"Age\", y = \"Population\") +\n  theme_classic()\n\n\n\n\n\n\n\n\n\n5.1 Good Points of the Visualization\n\n\n\n\n\n\nGood Points of the Visualization\n\n\n\n\nEffective Use of Symmetry for Comparison\n\nThe mirrored layout allows direct visual comparison between males and females across age groups, taking advantage of pre-attentive processing—our brains can instantly detect asymmetries or trends.\n\nClear Visual Contrast Between Genders\n\nThe use of distinct colors (#102E50 for Males and #F7CFD8 for Females) provides a strong contrast, making it easy to differentiate between the two groups at a glance.\n\nClean Axes and Labeling\n\nLabels are direct and aligned with the variable meanings (Age, Population) and axes are flipped for better age group readability—respecting orientation best practices for such charts.\n\n\n\n\n\n\n5.2 Areas for Further Improvement\n\n\n\n\n\n\nAreas for Further Improvement\n\n\n\n\nUnbalanced X-Axis for Population\n\nIssue: The x-axis (population) scale is not symmetric, making male and female distributions visually unequal even if numbers are comparable.\nImprovement: Use scale_y_continuous(limits = c(-max, max)) to ensure balanced comparison between both sides.\n\nLack of Data Labels\n\nIssue: The bars show magnitude but lack percentage or population labels, which limits interpretability, especially for identifying the proportion of each group.\nImprovement: Add geom_text() to display percentages (or absolute values), enhancing clarity and precision.\n\nLimited Context or Insights\n\nIssue: The chart has no subtitle and annotations to help viewers interpret demographic trends (e.g., aging population bulge).\nImprovement: Add a subtitle, annotations texts to guide interpretation and highlight key demographic observations.\n\n\n\n\n\n\n5.3 Makeover Version of the Data Visualization\n\npyramid_data &lt;- sgresidents_2024 %&gt;%\n  mutate(age = if_else(age == \"90_and_Over\", \"90\", age),\n         age = as.integer(age)) %&gt;%\n  filter(age &lt;= 100) %&gt;%\n  group_by(age, sex) %&gt;%\n  summarise(population = sum(pop), .groups = \"drop\") %&gt;%\n  mutate(population = if_else(sex == \"Females\", -population, population),\n         age = factor(age, levels = sort(unique(age))))  # Fix for axis labels\n\n\nage_totals &lt;- pyramid_data %&gt;%\n  group_by(age) %&gt;%\n  summarise(age_total = sum(abs(population)))\n\n\npyramid_data &lt;- pyramid_data %&gt;%\n  left_join(age_totals, by = \"age\") %&gt;%\n  mutate(percent = abs(population) / age_total * 100)\n\n\nggplot(pyramid_data, aes(x = age, y = population, fill = sex)) +\n  geom_bar(stat = \"identity\") +\n  coord_flip(clip = \"off\") +\n  scale_y_continuous(\n    labels = abs,\n    limits = c(-40000, 40000),\n    expand = c(0, 0)\n  ) +\n  scale_fill_manual(values = c(\"Males\" = \"#446AAB\", \"Females\" = \"#D97A95\")) + \n  geom_text(aes(label = paste0(round(percent, 1), \"%\")),\n            position = \"identity\",\n            hjust = ifelse(pyramid_data$sex == \"Males\", 1.05, -0.05),\n            size = 2.8,\n            color = \"white\") +\n  scale_x_discrete(breaks = seq(0, 100, by = 10)) +\n  annotate(\"text\", x = 95, y = -36000, label = \"Females\", color = \"#D97A95\", \n           size = 5, hjust = 0) +\n  annotate(\"text\", x = 95, y = 36000, label = \"Males\", color = \"#446AAB\", \n           size = 5, hjust = 1) +\n  labs(\n    title = \"Singapore Age Pyramid (2024)\",\n    subtitle = \"Females on the left (pink), Males on the right (blue),\",\n    x = \"Age\",\n    y = \"Population\"\n  ) +\n  theme_classic() +\n  theme(legend.position = \"top\",\n        axis.title.x = element_text(size = 25),\n        axis.title.y = element_text(size = 25),\n        axis.text.x = element_text(size = 15),\n        axis.text.y = element_text(size = 15),\n        plot.title = element_text(size = 30, face = \"bold\",hjust = 0.5),\n        plot.subtitle = element_text(size = 15, hjust = 0.5),\n        plot.margin = margin(10, 40, 10, 40),\n        legend.text = element_text(size = 15),\n        legend.title = element_text(size = 25))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nImprovements (makeover version vs original version)\n\n\n\n\nReversed Axis Annotation and Added Subtitle\n\nI swapped the annotation positions so that Females are labeled on the left (negative side) and Males on the right (positive side), matching the plot structure. Also by adding the subtitle under the plot title stating the positions and color of the male and female, which clears up confusion for viewers unfamiliar with the convention, making the chart easier to interpret.\n\nIncreased Plot Range and Margin for Visibility\n\nI expanded the scale_y_continuous() limits and margins, and used clip = \"off\" to ensure annotations were not cut off. This ensure that all labels and annotations are fully visible within the chart area.\n\nAdded Percent Labels Within Bars\n\nI used geom_text() to include the percentage distribution for each age group. Making the chart more informative at a glance, showing both proportion and distribution without requiring estimation.\n\n\n\n\n\n\n\n\n\n\nAdvantages (i.e. why do these improvements)\n\n\n\n\nEasier Interpretation for All Audiences\n\nAdding clear annotations (“Males” and “Females”) and a helpful subtitle guides viewers—especially those unfamiliar with population pyramids—to understand which side represents which gender, reducing misinterpretation.\n\nEnhanced Data Readability\n\nIncluding percentage labels inside the bars helps readers instantly grasp the proportion of each gender in each age group, without needing to estimate from the axis.\n\nImproved Visual Structure\n\nA more polished and comprehensive design is produced by adjusting the annotations and expanding the plot margins to ensure that all components—labels and annotations—are completely visible and not covered."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ISSS608-VAA-Huang Zihan",
    "section": "",
    "text": "Welcome to ISSS608 Visual Analytics and Application. In this website, you will find my coursework prepared for this course."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html",
    "title": "Hands-on_Ex06",
    "section": "",
    "text": "pacman:: p_load(scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table, tidyverse, CGPfunctions, ggHoriPlot)\n\n\n\n\n\n\n\nattacks &lt;- read_csv(\"eventlog.csv\")\n\n\n\n\nkable() can be used to review the structure of the imported data frame\nIn the following data structure:\n\n\n\n\n\n\n\n\n\nStored Value\nData Format\n\n\n\n\ntimestamp\ndate-time\nPOSIXct format\n\n\nsource_country\nthe source of the attack\nISO 3166-1 alpha-2 country code\n\n\ntz\ntime zone of the source IP address\n\n\n\n\n\nkable(head(attacks))\n\n\n\n\ntimestamp\nsource_country\ntz\n\n\n\n\n2015-03-12 15:59:16\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:00:48\nFR\nEurope/Paris\n\n\n2015-03-12 16:02:26\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:02:38\nUS\nAmerica/Chicago\n\n\n2015-03-12 16:03:22\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:03:45\nCN\nAsia/Shanghai\n\n\n\n\n\n\n\n\n\n\n\nmake_hr_wkday &lt;- function(ts, sc, tz) {\n  real_times &lt;- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt &lt;- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n\n\n\n\nmutate() of dplyr package is used to convert weekday and hour fields into factor so they’ll be ordered when plotting\n\nwkday_levels &lt;- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks &lt;- attacks %&gt;%\n  group_by(tz) %&gt;%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %&gt;% \n  ungroup() %&gt;% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n\nTable below shows the tidy tibble table after processing.\n\nkable(head(attacks))\n\n\n\n\ntz\nsource_country\nwkday\nhour\n\n\n\n\nAfrica/Cairo\nBG\nSaturday\n20\n\n\nAfrica/Cairo\nTW\nSunday\n6\n\n\nAfrica/Cairo\nTW\nSunday\n8\n\n\nAfrica/Cairo\nCN\nSunday\n11\n\n\nAfrica/Cairo\nUS\nSunday\n15\n\n\nAfrica/Cairo\nCA\nMonday\n11\n\n\n\n\n\n\n\n\n\n\nna.omit() is used to exclude missing value.\ngeom_tile() is used to plot tiles (grids) at each x and y position.\ntheme_tufte() of ggthemes package is used to remove unnecessary chart junk.\ncoord_equal() is used to ensure the plot will have an aspect ratio of 1:1.\nscale_fill_gradient() function is used to creates a two colour gradient (low-high).\n\n\ngrouped &lt;- attacks %&gt;% \n  count(wkday, hour) %&gt;% \n  ungroup() %&gt;%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nattacks_by_country &lt;- count(\n  attacks, source_country) %&gt;% # count the number of attacks by country\n  mutate(percent = percent(n/sum(n))) %&gt;%\n  # calculate the percent of attackes by country\n  arrange(desc(n)) # save the results in a tibble data frame\n\n\n\n\n\ntop4 &lt;- attacks_by_country$source_country[1:4]\ntop4_attacks &lt;- attacks %&gt;%\n  filter(source_country %in% top4) %&gt;%\n  count(source_country, wkday, hour) %&gt;%\n  ungroup() %&gt;%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %&gt;%\n  na.omit()\n\n\n\n\n\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nair &lt;- read_excel(\"arrivals_by_air.xlsx\")\n\n\n\n\n\nair$month &lt;- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year &lt;- year(ymd(air$`Month-Year`))\n\n\n\n\n\nVietnam &lt;- air %&gt;% \n  select(`Vietnam`, \n         month, \n         year) %&gt;%\n  filter(year &gt;= 2010)\n\n\n\n\n\nhline.data &lt;- Vietnam %&gt;% \n  group_by(month) %&gt;%\n  summarise(avgvalue = mean(`Vietnam`))\n\n\n\n\n\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_tufte(base_family = \"Helvetica\")+\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nrice &lt;- read_csv(\"rice.csv\")\n\n\n\n\n\nrice %&gt;% \n  mutate(Year = factor(Year)) %&gt;%\n  filter(Year %in% c(1961, 1980)) %&gt;%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Huang Zihan\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#loading-r-packages",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#loading-r-packages",
    "title": "Hands-on_Ex06",
    "section": "",
    "text": "pacman:: p_load(scales, viridis, lubridate, ggthemes, gridExtra, readxl, knitr, data.table, tidyverse, CGPfunctions, ggHoriPlot)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-calendar-heatmap",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-calendar-heatmap",
    "title": "Hands-on_Ex06",
    "section": "",
    "text": "attacks &lt;- read_csv(\"eventlog.csv\")\n\n\n\n\nkable() can be used to review the structure of the imported data frame\nIn the following data structure:\n\n\n\n\n\n\n\n\n\nStored Value\nData Format\n\n\n\n\ntimestamp\ndate-time\nPOSIXct format\n\n\nsource_country\nthe source of the attack\nISO 3166-1 alpha-2 country code\n\n\ntz\ntime zone of the source IP address\n\n\n\n\n\nkable(head(attacks))\n\n\n\n\ntimestamp\nsource_country\ntz\n\n\n\n\n2015-03-12 15:59:16\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:00:48\nFR\nEurope/Paris\n\n\n2015-03-12 16:02:26\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:02:38\nUS\nAmerica/Chicago\n\n\n2015-03-12 16:03:22\nCN\nAsia/Shanghai\n\n\n2015-03-12 16:03:45\nCN\nAsia/Shanghai\n\n\n\n\n\n\n\n\n\n\n\nmake_hr_wkday &lt;- function(ts, sc, tz) {\n  real_times &lt;- ymd_hms(ts, \n                        tz = tz[1], \n                        quiet = TRUE)\n  dt &lt;- data.table(source_country = sc,\n                   wkday = weekdays(real_times),\n                   hour = hour(real_times))\n  return(dt)\n  }\n\n\n\n\nmutate() of dplyr package is used to convert weekday and hour fields into factor so they’ll be ordered when plotting\n\nwkday_levels &lt;- c('Saturday', 'Friday', \n                  'Thursday', 'Wednesday', \n                  'Tuesday', 'Monday', \n                  'Sunday')\n\nattacks &lt;- attacks %&gt;%\n  group_by(tz) %&gt;%\n  do(make_hr_wkday(.$timestamp, \n                   .$source_country, \n                   .$tz)) %&gt;% \n  ungroup() %&gt;% \n  mutate(wkday = factor(\n    wkday, levels = wkday_levels),\n    hour  = factor(\n      hour, levels = 0:23))\n\nTable below shows the tidy tibble table after processing.\n\nkable(head(attacks))\n\n\n\n\ntz\nsource_country\nwkday\nhour\n\n\n\n\nAfrica/Cairo\nBG\nSaturday\n20\n\n\nAfrica/Cairo\nTW\nSunday\n6\n\n\nAfrica/Cairo\nTW\nSunday\n8\n\n\nAfrica/Cairo\nCN\nSunday\n11\n\n\nAfrica/Cairo\nUS\nSunday\n15\n\n\nAfrica/Cairo\nCA\nMonday\n11\n\n\n\n\n\n\n\n\n\n\nna.omit() is used to exclude missing value.\ngeom_tile() is used to plot tiles (grids) at each x and y position.\ntheme_tufte() of ggthemes package is used to remove unnecessary chart junk.\ncoord_equal() is used to ensure the plot will have an aspect ratio of 1:1.\nscale_fill_gradient() function is used to creates a two colour gradient (low-high).\n\n\ngrouped &lt;- attacks %&gt;% \n  count(wkday, hour) %&gt;% \n  ungroup() %&gt;%\n  na.omit()\n\nggplot(grouped, \n       aes(hour, \n           wkday, \n           fill = n)) + \ngeom_tile(color = \"white\", \n          size = 0.1) + \ntheme_tufte(base_family = \"Helvetica\") + \ncoord_equal() +\nscale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\nlabs(x = NULL, \n     y = NULL, \n     title = \"Attacks by weekday and time of day\") +\ntheme(axis.ticks = element_blank(),\n      plot.title = element_text(hjust = 0.5),\n      legend.title = element_text(size = 8),\n      legend.text = element_text(size = 6) )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nattacks_by_country &lt;- count(\n  attacks, source_country) %&gt;% # count the number of attacks by country\n  mutate(percent = percent(n/sum(n))) %&gt;%\n  # calculate the percent of attackes by country\n  arrange(desc(n)) # save the results in a tibble data frame\n\n\n\n\n\ntop4 &lt;- attacks_by_country$source_country[1:4]\ntop4_attacks &lt;- attacks %&gt;%\n  filter(source_country %in% top4) %&gt;%\n  count(source_country, wkday, hour) %&gt;%\n  ungroup() %&gt;%\n  mutate(source_country = factor(\n    source_country, levels = top4)) %&gt;%\n  na.omit()\n\n\n\n\n\nggplot(top4_attacks, \n       aes(hour, \n           wkday, \n           fill = n)) + \n  geom_tile(color = \"white\", \n          size = 0.1) + \n  theme_tufte(base_family = \"Helvetica\") + \n  coord_equal() +\n  scale_fill_gradient(name = \"# of attacks\",\n                    low = \"sky blue\", \n                    high = \"dark blue\") +\n  facet_wrap(~source_country, ncol = 2) +\n  labs(x = NULL, y = NULL, \n     title = \"Attacks on top 4 countries by weekday and time of day\") +\n  theme(axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 7),\n        plot.title = element_text(hjust = 0.5),\n        legend.title = element_text(size = 8),\n        legend.text = element_text(size = 6) )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-cycle-plot",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-cycle-plot",
    "title": "Hands-on_Ex06",
    "section": "",
    "text": "air &lt;- read_excel(\"arrivals_by_air.xlsx\")\n\n\n\n\n\nair$month &lt;- factor(month(air$`Month-Year`), \n                    levels=1:12, \n                    labels=month.abb, \n                    ordered=TRUE) \nair$year &lt;- year(ymd(air$`Month-Year`))\n\n\n\n\n\nVietnam &lt;- air %&gt;% \n  select(`Vietnam`, \n         month, \n         year) %&gt;%\n  filter(year &gt;= 2010)\n\n\n\n\n\nhline.data &lt;- Vietnam %&gt;% \n  group_by(month) %&gt;%\n  summarise(avgvalue = mean(`Vietnam`))\n\n\n\n\n\nggplot() + \n  geom_line(data=Vietnam,\n            aes(x=year, \n                y=`Vietnam`, \n                group=month), \n            colour=\"black\") +\n  geom_hline(aes(yintercept=avgvalue), \n             data=hline.data, \n             linetype=6, \n             colour=\"red\", \n             size=0.5) + \n  facet_grid(~month) +\n  labs(axis.text.x = element_blank(),\n       title = \"Visitor arrivals from Vietnam by air, Jan 2010-Dec 2019\") +\n  xlab(\"\") +\n  ylab(\"No. of Visitors\") +\n  theme_tufte(base_family = \"Helvetica\")+\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 6))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-slopegraph",
    "href": "Hands-on_Ex/Hands-on_Ex06/Hands-on_Ex06.html#plotting-slopegraph",
    "title": "Hands-on_Ex06",
    "section": "",
    "text": "rice &lt;- read_csv(\"rice.csv\")\n\n\n\n\n\nrice %&gt;% \n  mutate(Year = factor(Year)) %&gt;%\n  filter(Year %in% c(1961, 1980)) %&gt;%\n  newggslopegraph(Year, Yield, Country,\n                Title = \"Rice Yield of Top 11 Asian Counties\",\n                SubTitle = \"1961-1980\",\n                Caption = \"Prepared by: Huang Zihan\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-1.html",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-1.html",
    "title": "Hands-on_Ex08-1",
    "section": "",
    "text": "tmap for plotting functional and truthful choropleth maps\nreadr for importing delimited text file (part of tidyverse package)\ntidyr for tidying data (part of tidyverse package)\ndplyr for wrangling data and sf for handling geospatial data (part of tidyverse package)\n\n\npacman::p_load(sf, tmap, tidyverse)\n\n\n\n\n\n\nThe code chunk below uses the st_read() function of sf package to import MP14_SUBZONE_WEB_PL shapefile into R as a simple feature data frame called mpsz.\n\nmpsz &lt;- st_read(dsn = \"data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/huangzihan/huangzihan905/ISSS608-VAA/Hands-on_Ex/Hands-on_Ex08/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nThe content of mpsz is examined by using the code chunk below.\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n\n\n\n\n\nNext, we will import respopagsex2011to2020.csv file into RStudio and save the file into an R dataframe called popagsex.\nThe task will be performed by using read_csv() function of readr package as shown in the code chunk below.\n\npopdata &lt;- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n\n\n\n\nTo prepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.\n\nYOUNG: age group 0 to 4 until age group 20 to 24\nECONOMY ACTIVE: age group 25-29 until age group 60-64\nAGED: age group 65 and above\nTOTAL: all age group\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\n\nThe following data wrangling and transformation functions will be used:\n\npivot_wider() of tidyr package\nmutate(), filter(), group_by() and select() of dplyr package\n\n\npopdata2020 &lt;- popdata %&gt;%\n  filter(Time == 2020) %&gt;%\n  group_by(PA, SZ, AG) %&gt;%\n  summarise(`POP` = sum(`Pop`)) %&gt;%\n  ungroup() %&gt;%\n  pivot_wider(names_from=AG, \n              values_from=POP) %&gt;%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %&gt;%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%&gt;%\nmutate(`AGED`=rowSums(.[16:21])) %&gt;%\nmutate(`TOTAL`=rowSums(.[3:21])) %&gt;%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %&gt;%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n\n\n\n\nOne extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.\n\npopdata2020 &lt;- popdata2020 %&gt;%\n  mutate(across(c(PA, SZ), toupper)) %&gt;%\n  filter(`ECONOMY ACTIVE` &gt; 0)\n\nNext, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name e.g. SUBZONE_N and SZ as the common identifier.\nleft_join() of dplyr package is used with mpsz simple feature data frame as the left data table is to ensure that the output will be a simple features data frame.\n\nmpsz_pop2020 &lt;- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\nwrite_rds(mpsz_pop2020, \"data/rds/mpszpop2020.rds\")\n\n\n\n\n\n\nTwo approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\n\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\ntmap_mode(\"plot\")\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n\n\n\n\n\n\n\n\n\n\n\nThe disadvantge of qtm() is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, tmap’s drawing elements should be used.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\", \n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                title = \"Dependency ratio\")) +\n  tm_title(\"Distribution of Dependency Ratio by planning subzone\") +\n  tm_layout(frame = TRUE) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\nThe basic building block of tmap is tm_shape() followed by one or more layer elements such as tm_fill() and tm_polygons().\nIn the code chunk below, tm_shape() is used to define the input data (i.e mpsz_pop2020) and tm_polygons() is used to draw the planning subzone polygons\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from tm_polygons():\n\nThe default interval binning used to draw the choropleth map is called “pretty”.\nThe default colour scheme used is YlOrRd of ColorBrewer.\nBy default, Missing value will be shaded in grey.\n\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\n\n\n\n\n\n\n\ntm_polygons() is a wraper of tm_fill() and tm_border(). tm_fill() shades the polygons by using the default colour scheme and tm_borders() adds the borders of the shapefile onto the choropleth map.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\n\n\n\n\nNotice that the planning subzones are shared according to the respective dependecy values\nTo add the boundary of the planning subzones, tm_borders will be used as shown in the code chunk below.\nThe alpha argument is used to define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the col is used (normally 1).\nBeside alpha argument, there are three other arguments for tm_borders(), they are:\ncol = border colour, lwd = border line width. The default is 1, and lty = border line type. The default is “solid”.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\") +\n  tm_borders(lwd = 0.01,  \n             fill_alpha = 0.1)\n\n\n\n\n\n\n\n\n\n\n\n\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\n\nThe code chunk below shows a quantile data classification that used 5 classes.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"jenks\",\n        n = 5)) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\nIn the code chunk below, equal data classification method is used.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"equal\",\n        n = 5)) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\", \n              fill.scale = tm_scale_intervals(\n                style = \"equal\",\n                n = 5,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(title = \"Dependency ratio\")) +\n  tm_title(\"Equal Interval Classification (5 classes)\") +\n  tm_layout(frame = TRUE) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type = \"8star\", size = 2) +\n  tm_grid(alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from URA\\nand Population data from DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.1111  0.7147  0.7867  0.8585  0.8763 19.0000      92 \n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.\nTo change the colour, we assign the preferred colour to values argument of tm_scale_intervals() as shown in the code chunk below.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"quantile\",\n        n = 5,\n        values = \"brewer.greens\")) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\nTo reverse the colour shading, add a “-” prefix.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"quantile\",\n        n = 5,\n        values = \"-brewer.greens\")) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn tmap, several tm_legend() options are provided to change the placement, format and appearance of the legend.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"jenks\",\n        n = 5,\n        values = \"brewer.greens\"),\n      fill.legend = tm_legend(\n        title = \"Dependency ratio\")) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_title(\"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\")\n\n\n\n\n\n\n\n\n\n\n\ntmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style().\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\n\n\n\n\n\n\n\n\n\n\nBeside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.\nIn the code chunk below, tm_compass(), tm_scale_bar() and tm_grid() are used to add compass, scale bar and grid lines onto the choropleth map.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\", \n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                title = \"Dependency ratio\")) +\n  tm_title(\"Distribution of Dependency Ratio by planning subzone\") +\n  tm_layout(frame = TRUE) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\n\n\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments\nby defining a group-by variable in tm_facets()\nby creating multiple stand-alone maps with tmap_arrange()\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\n\n\n\n\n\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\nyoungmap &lt;- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap &lt;- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-1.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-1.html#getting-started",
    "title": "Hands-on_Ex08-1",
    "section": "",
    "text": "tmap for plotting functional and truthful choropleth maps\nreadr for importing delimited text file (part of tidyverse package)\ntidyr for tidying data (part of tidyverse package)\ndplyr for wrangling data and sf for handling geospatial data (part of tidyverse package)\n\n\npacman::p_load(sf, tmap, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-1.html#importing-data",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-1.html#importing-data",
    "title": "Hands-on_Ex08-1",
    "section": "",
    "text": "The code chunk below uses the st_read() function of sf package to import MP14_SUBZONE_WEB_PL shapefile into R as a simple feature data frame called mpsz.\n\nmpsz &lt;- st_read(dsn = \"data/geospatial\", \n                layer = \"MP14_SUBZONE_WEB_PL\")\n\nReading layer `MP14_SUBZONE_WEB_PL' from data source \n  `/Users/huangzihan/huangzihan905/ISSS608-VAA/Hands-on_Ex/Hands-on_Ex08/data/geospatial' \n  using driver `ESRI Shapefile'\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\n\n\nThe content of mpsz is examined by using the code chunk below.\n\nmpsz\n\nSimple feature collection with 323 features and 15 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: 2667.538 ymin: 15748.72 xmax: 56396.44 ymax: 50256.33\nProjected CRS: SVY21\nFirst 10 features:\n   OBJECTID SUBZONE_NO       SUBZONE_N SUBZONE_C CA_IND      PLN_AREA_N\n1         1          1    MARINA SOUTH    MSSZ01      Y    MARINA SOUTH\n2         2          1    PEARL'S HILL    OTSZ01      Y          OUTRAM\n3         3          3       BOAT QUAY    SRSZ03      Y SINGAPORE RIVER\n4         4          8  HENDERSON HILL    BMSZ08      N     BUKIT MERAH\n5         5          3         REDHILL    BMSZ03      N     BUKIT MERAH\n6         6          7  ALEXANDRA HILL    BMSZ07      N     BUKIT MERAH\n7         7          9   BUKIT HO SWEE    BMSZ09      N     BUKIT MERAH\n8         8          2     CLARKE QUAY    SRSZ02      Y SINGAPORE RIVER\n9         9         13 PASIR PANJANG 1    QTSZ13      N      QUEENSTOWN\n10       10          7       QUEENSWAY    QTSZ07      N      QUEENSTOWN\n   PLN_AREA_C       REGION_N REGION_C          INC_CRC FMEL_UPD_D   X_ADDR\n1          MS CENTRAL REGION       CR 5ED7EB253F99252E 2014-12-05 31595.84\n2          OT CENTRAL REGION       CR 8C7149B9EB32EEFC 2014-12-05 28679.06\n3          SR CENTRAL REGION       CR C35FEFF02B13E0E5 2014-12-05 29654.96\n4          BM CENTRAL REGION       CR 3775D82C5DDBEFBD 2014-12-05 26782.83\n5          BM CENTRAL REGION       CR 85D9ABEF0A40678F 2014-12-05 26201.96\n6          BM CENTRAL REGION       CR 9D286521EF5E3B59 2014-12-05 25358.82\n7          BM CENTRAL REGION       CR 7839A8577144EFE2 2014-12-05 27680.06\n8          SR CENTRAL REGION       CR 48661DC0FBA09F7A 2014-12-05 29253.21\n9          QT CENTRAL REGION       CR 1F721290C421BFAB 2014-12-05 22077.34\n10         QT CENTRAL REGION       CR 3580D2AFFBEE914C 2014-12-05 24168.31\n     Y_ADDR SHAPE_Leng SHAPE_Area                       geometry\n1  29220.19   5267.381  1630379.3 MULTIPOLYGON (((31495.56 30...\n2  29782.05   3506.107   559816.2 MULTIPOLYGON (((29092.28 30...\n3  29974.66   1740.926   160807.5 MULTIPOLYGON (((29932.33 29...\n4  29933.77   3313.625   595428.9 MULTIPOLYGON (((27131.28 30...\n5  30005.70   2825.594   387429.4 MULTIPOLYGON (((26451.03 30...\n6  29991.38   4428.913  1030378.8 MULTIPOLYGON (((25899.7 297...\n7  30230.86   3275.312   551732.0 MULTIPOLYGON (((27746.95 30...\n8  30222.86   2208.619   290184.7 MULTIPOLYGON (((29351.26 29...\n9  29893.78   6571.323  1084792.3 MULTIPOLYGON (((20996.49 30...\n10 30104.18   3454.239   631644.3 MULTIPOLYGON (((24472.11 29...\n\n\n\n\n\nNext, we will import respopagsex2011to2020.csv file into RStudio and save the file into an R dataframe called popagsex.\nThe task will be performed by using read_csv() function of readr package as shown in the code chunk below.\n\npopdata &lt;- read_csv(\"data/aspatial/respopagesextod2011to2020.csv\")\n\n\n\n\nTo prepare a data table with year 2020 values. The data table should include the variables PA, SZ, YOUNG, ECONOMY ACTIVE, AGED, TOTAL, DEPENDENCY.\n\nYOUNG: age group 0 to 4 until age group 20 to 24\nECONOMY ACTIVE: age group 25-29 until age group 60-64\nAGED: age group 65 and above\nTOTAL: all age group\nDEPENDENCY: the ratio between young and aged against economy active group\n\n\n\nThe following data wrangling and transformation functions will be used:\n\npivot_wider() of tidyr package\nmutate(), filter(), group_by() and select() of dplyr package\n\n\npopdata2020 &lt;- popdata %&gt;%\n  filter(Time == 2020) %&gt;%\n  group_by(PA, SZ, AG) %&gt;%\n  summarise(`POP` = sum(`Pop`)) %&gt;%\n  ungroup() %&gt;%\n  pivot_wider(names_from=AG, \n              values_from=POP) %&gt;%\n  mutate(YOUNG = rowSums(.[3:6])\n         +rowSums(.[12])) %&gt;%\nmutate(`ECONOMY ACTIVE` = rowSums(.[7:11])+\nrowSums(.[13:15]))%&gt;%\nmutate(`AGED`=rowSums(.[16:21])) %&gt;%\nmutate(`TOTAL`=rowSums(.[3:21])) %&gt;%  \nmutate(`DEPENDENCY` = (`YOUNG` + `AGED`)\n/`ECONOMY ACTIVE`) %&gt;%\n  select(`PA`, `SZ`, `YOUNG`, \n       `ECONOMY ACTIVE`, `AGED`, \n       `TOTAL`, `DEPENDENCY`)\n\n\n\n\nOne extra step is required to convert the values in PA and SZ fields to uppercase. This is because the values of PA and SZ fields are made up of upper- and lowercase. On the other, hand the SUBZONE_N and PLN_AREA_N are in uppercase.\n\npopdata2020 &lt;- popdata2020 %&gt;%\n  mutate(across(c(PA, SZ), toupper)) %&gt;%\n  filter(`ECONOMY ACTIVE` &gt; 0)\n\nNext, left_join() of dplyr is used to join the geographical data and attribute table using planning subzone name e.g. SUBZONE_N and SZ as the common identifier.\nleft_join() of dplyr package is used with mpsz simple feature data frame as the left data table is to ensure that the output will be a simple features data frame.\n\nmpsz_pop2020 &lt;- left_join(mpsz, popdata2020,\n                          by = c(\"SUBZONE_N\" = \"SZ\"))\n\nwrite_rds(mpsz_pop2020, \"data/rds/mpszpop2020.rds\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-1.html#choropleth-mapping-geospatial-data-using-tmap",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-1.html#choropleth-mapping-geospatial-data-using-tmap",
    "title": "Hands-on_Ex08-1",
    "section": "",
    "text": "Two approaches can be used to prepare thematic map using tmap, they are:\n\nPlotting a thematic map quickly by using qtm().\nPlotting highly customisable thematic map by using tmap elements.\n\n\n\n\ntmap_mode() with “plot” option is used to produce a static map. For interactive mode, “view” option should be used.\nfill argument is used to map the attribute (i.e. DEPENDENCY)\n\n\ntmap_mode(\"plot\")\nqtm(mpsz_pop2020, \n    fill = \"DEPENDENCY\")\n\n\n\n\n\n\n\n\n\n\n\nThe disadvantge of qtm() is that it makes aesthetics of individual layers harder to control. To draw a high quality cartographic choropleth map as shown in the figure below, tmap’s drawing elements should be used.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\", \n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                title = \"Dependency ratio\")) +\n  tm_title(\"Distribution of Dependency Ratio by planning subzone\") +\n  tm_layout(frame = TRUE) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\nThe basic building block of tmap is tm_shape() followed by one or more layer elements such as tm_fill() and tm_polygons().\nIn the code chunk below, tm_shape() is used to define the input data (i.e mpsz_pop2020) and tm_polygons() is used to draw the planning subzone polygons\n\ntm_shape(mpsz_pop2020) +\n  tm_polygons()\n\n\n\n\n\n\n\n\n\n\n\nThings to learn from tm_polygons():\n\nThe default interval binning used to draw the choropleth map is called “pretty”.\nThe default colour scheme used is YlOrRd of ColorBrewer.\nBy default, Missing value will be shaded in grey.\n\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\")\n\n\n\n\n\n\n\n\n\n\n\ntm_polygons() is a wraper of tm_fill() and tm_border(). tm_fill() shades the polygons by using the default colour scheme and tm_borders() adds the borders of the shapefile onto the choropleth map.\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\")\n\n\n\n\n\n\n\n\nNotice that the planning subzones are shared according to the respective dependecy values\nTo add the boundary of the planning subzones, tm_borders will be used as shown in the code chunk below.\nThe alpha argument is used to define transparency number between 0 (totally transparent) and 1 (not transparent). By default, the alpha value of the col is used (normally 1).\nBeside alpha argument, there are three other arguments for tm_borders(), they are:\ncol = border colour, lwd = border line width. The default is 1, and lty = border line type. The default is “solid”.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\") +\n  tm_borders(lwd = 0.01,  \n             fill_alpha = 0.1)\n\n\n\n\n\n\n\n\n\n\n\n\ntmap provides a total ten data classification methods, namely: fixed, sd, equal, pretty (default), quantile, kmeans, hclust, bclust, fisher, and jenks.\nTo define a data classification method, the style argument of tm_fill() or tm_polygons() will be used.\n\n\nThe code chunk below shows a quantile data classification that used 5 classes.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"jenks\",\n        n = 5)) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\nIn the code chunk below, equal data classification method is used.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"equal\",\n        n = 5)) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\", \n              fill.scale = tm_scale_intervals(\n                style = \"equal\",\n                n = 5,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(title = \"Dependency ratio\")) +\n  tm_title(\"Equal Interval Classification (5 classes)\") +\n  tm_layout(frame = TRUE) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type = \"8star\", size = 2) +\n  tm_grid(alpha = 0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from URA\\nand Population data from DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\n\nsummary(mpsz_pop2020$DEPENDENCY)\n\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n 0.1111  0.7147  0.7867  0.8585  0.8763 19.0000      92 \n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n          breaks = c(0, 0.60, 0.70, 0.80, 0.90, 1.00)) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\ntmap supports colour ramps either defined by the user or a set of predefined colour ramps from the RColorBrewer package.\nTo change the colour, we assign the preferred colour to values argument of tm_scale_intervals() as shown in the code chunk below.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"quantile\",\n        n = 5,\n        values = \"brewer.greens\")) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\nTo reverse the colour shading, add a “-” prefix.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"quantile\",\n        n = 5,\n        values = \"-brewer.greens\")) +\n  tm_borders(fill_alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn tmap, several tm_legend() options are provided to change the placement, format and appearance of the legend.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(\"DEPENDENCY\",\n      fill.scale = tm_scale_intervals(\n        style = \"jenks\",\n        n = 5,\n        values = \"brewer.greens\"),\n      fill.legend = tm_legend(\n        title = \"Dependency ratio\")) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_title(\"Distribution of Dependency Ratio by planning subzone \\n(Jenks classification)\")\n\n\n\n\n\n\n\n\n\n\n\ntmap allows a wide variety of layout settings to be changed. They can be called by using tmap_style().\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"-Greens\") +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"classic\")\n\n\n\n\n\n\n\n\n\n\n\nBeside map style, tmap also also provides arguments to draw other map furniture such as compass, scale bar and grid lines.\nIn the code chunk below, tm_compass(), tm_scale_bar() and tm_grid() are used to add compass, scale bar and grid lines onto the choropleth map.\n\ntm_shape(mpsz_pop2020)+\n  tm_polygons(fill = \"DEPENDENCY\", \n              fill.scale = tm_scale_intervals(\n                style = \"quantile\",\n                n = 5,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                title = \"Dependency ratio\")) +\n  tm_title(\"Distribution of Dependency Ratio by planning subzone\") +\n  tm_layout(frame = TRUE) +\n  tm_borders(fill_alpha = 0.5) +\n  tm_compass(type=\"8star\", size = 2) +\n  tm_grid(alpha =0.2) +\n  tm_credits(\"Source: Planning Sub-zone boundary from Urban Redevelopment Authorithy (URA)\\n and Population data from Department of Statistics DOS\", \n             position = c(\"left\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\n\n\nSmall multiple maps, also referred to as facet maps, are composed of many maps arrange side-by-side, and sometimes stacked vertically. Small multiple maps enable the visualisation of how spatial relationships change with respect to another variable, such as time.\nIn tmap, small multiple maps can be plotted in three ways:\n\nby assigning multiple values to at least one of the asthetic arguments\nby defining a group-by variable in tm_facets()\nby creating multiple stand-alone maps with tmap_arrange()\n\n\n\n\ntm_shape(mpsz_pop2020)+\n  tm_fill(c(\"YOUNG\", \"AGED\"),\n          style = \"equal\", \n          palette = \"Blues\") +\n  tm_layout(legend.position = c(\"right\", \"bottom\")) +\n  tm_borders(alpha = 0.5) +\n  tmap_style(\"white\")\n\n\n\n\n\n\n\n\nIn this example, small multiple choropleth maps are created by assigning multiple values to at least one of the aesthetic arguments\n\ntm_shape(mpsz_pop2020)+ \n  tm_polygons(c(\"DEPENDENCY\",\"AGED\"),\n          style = c(\"equal\", \"quantile\"), \n          palette = list(\"Blues\",\"Greens\")) +\n  tm_layout(legend.position = c(\"right\", \"bottom\"))\n\n\n\n\n\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020) +\n  tm_fill(\"DEPENDENCY\",\n          style = \"quantile\",\n          palette = \"Blues\",\n          thres.poly = 0) + \n  tm_facets(by=\"REGION_N\", \n            free.coords=TRUE) +\n  tm_layout(legend.show = FALSE,\n            title.position = c(\"center\", \"center\"), \n            title.size = 20) +\n  tm_borders(alpha = 0.5)\n\n\n\n\n\n\n\n\n\n\n\n\nyoungmap &lt;- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"YOUNG\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\nagedmap &lt;- tm_shape(mpsz_pop2020)+ \n  tm_polygons(\"AGED\", \n              style = \"quantile\", \n              palette = \"Blues\")\n\ntmap_arrange(youngmap, agedmap, asp=1, ncol=2)\n\n\n\n\n\n\n\n\n\n\n\n\n\ntm_shape(mpsz_pop2020[mpsz_pop2020$REGION_N==\"CENTRAL REGION\", ])+\n  tm_fill(\"DEPENDENCY\", \n          style = \"quantile\", \n          palette = \"Blues\", \n          legend.hist = TRUE, \n          legend.is.portrait = TRUE,\n          legend.hist.z = 0.1) +\n  tm_layout(legend.outside = TRUE,\n            legend.height = 0.45, \n            legend.width = 5.0,\n            legend.position = c(\"right\", \"bottom\"),\n            frame = FALSE) +\n  tm_borders(alpha = 0.5)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html",
    "title": "Hands-on_Ex08-3",
    "section": "",
    "text": "pacman::p_load(tmap, tidyverse, sf)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#installing-and-loading-packages",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#installing-and-loading-packages",
    "title": "Hands-on_Ex08-3",
    "section": "",
    "text": "pacman::p_load(tmap, tidyverse, sf)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#visualising-distribution-of-non-functional-water-point",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#visualising-distribution-of-non-functional-water-point",
    "title": "Hands-on_Ex08-3",
    "section": "Visualising distribution of non-functional water point",
    "text": "Visualising distribution of non-functional water point\nPlot a choropleth map showing the distribution of non-function water point by LGA\n\np1 &lt;- tm_shape(NGA_wp) +\n  tm_polygons(fill = \"wp_functional\",\n             fill.scale = tm_scale_intervals(\n               style = \"equal\",\n               n = 10,\n               values = \"brewer.blues\"),\n             fill.legend = tm_legend(\n               position = c(\"right\", \"bottom\"))) +\n  tm_borders(lwd = 0.1,\n             fill_alpha = 1) +\n  tm_title(\"Distribution of functional water point by LGAs\")\n\n\np2 &lt;- tm_shape(NGA_wp) + \n  tm_polygons(fill = \"total_wp\", \n              fill.scale = tm_scale_intervals(\n                style = \"equal\",\n                n = 10,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                position = c(\"right\", \"bottom\"))) +\n  tm_borders(lwd = 0.1, \n             fill_alpha = 1) + \n  tm_title(\"Distribution of total  water point by LGAs\")\n\n\ntmap_arrange(p2, p1, nrow = 1)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#deriving-proportion-of-functional-water-points-and-non-functional-water-points",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#deriving-proportion-of-functional-water-points-and-non-functional-water-points",
    "title": "Hands-on_Ex08-3",
    "section": "Deriving Proportion of Functional Water Points and Non-Functional Water Points",
    "text": "Deriving Proportion of Functional Water Points and Non-Functional Water Points\nWe use mutate() from the dplyr package to calculate pct_functional and pct_nonfunctional, representing the proportions of functional and non-functional water points per LGA.\n\nNGA_wp &lt;- NGA_wp %&gt;%\n  mutate(pct_functional = wp_functional/total_wp) %&gt;%\n  mutate(pct_nonfunctional = wp_nonfunctional/total_wp)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#plotting-map-of-rate",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#plotting-map-of-rate",
    "title": "Hands-on_Ex08-3",
    "section": "Plotting map of rate",
    "text": "Plotting map of rate\nPlot a choropleth map showing the distribution of percentage functional water point by LGA\n\ntm_shape(NGA_wp) +\n  tm_polygons(\"pct_functional\",\n              fill.scale = tm_scale_intervals(\n                style = \"equal\",\n                n = 10,\n                values = \"brewer.blues\"),\n              fill.legend = tm_legend(\n                position = c(\"right\", \"bottom\"))) + \n  tm_borders(lwd = 0.1,\n             fill_alpha = 1) +\n  tm_title(\"Rate map of functional water point by LGAs\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#percentile-map",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#percentile-map",
    "title": "Hands-on_Ex08-3",
    "section": "Percentile Map",
    "text": "Percentile Map\nA percentile map is a specialized quantile map with six categories, using breakpoints from quantile() with cumulative probabilities c(0, .01, .1, .5, .9, .99, 1), ensuring both endpoints are included.\n\nData Preparation\nStep 1: Exclude records with NA by using the code chunk below.\n\nNGA_wp &lt;- NGA_wp %&gt;%\n  drop_na()\n\nStep 2: Creating customised classification and extracting values\n\npercent &lt;- c(0,.01,.1,.5,.9,.99,1)\nvar &lt;- NGA_wp[\"pct_functional\"] %&gt;%\n  st_set_geometry(NULL)\nquantile(var[,1], percent)\n\n       0%        1%       10%       50%       90%       99%      100% \n0.0000000 0.0000000 0.2169811 0.4791667 0.8611111 1.0000000 1.0000000 \n\n\n\n\nCreating the get.var function\nWe define an R function to extract a variable (e.g., wp_nonfunctional) as a named vector from an sf data frame using vname (as a string) and df as inputs.\n\nget.var &lt;- function(vname,df) {\n  v &lt;- df[vname] %&gt;% \n    st_set_geometry(NULL)\n  v &lt;- unname(v[,1])\n  return(v)\n}\n\n\n\nA percentile mapping function\nNext, we will write a percentile mapping function by using the code chunk below.\n\npercentmap &lt;- function(vnam, df, legtitle=NA, mtitle=\"Percentile Map\"){\n  percent &lt;- c(0,.01,.1,.5,.9,.99,1)\n  var &lt;- get.var(vnam, df)\n  bperc &lt;- quantile(var, percent)\n  tm_shape(df) +\n  tm_polygons() +\n  tm_shape(df) +\n     tm_polygons(vnam,\n             title=legtitle,\n             breaks=bperc,\n             palette=\"Blues\",\n          labels=c(\"&lt; 1%\", \"1% - 10%\", \"10% - 50%\", \"50% - 90%\", \"90% - 99%\", \"&gt; 99%\"))  +\n  tm_borders() +\n  tm_layout(main.title = mtitle, \n            title.position = c(\"right\",\"bottom\"))\n}\n\n\n\nTest drive the percentile mapping function\nTo run the function, type the code chunk as shown below.\n\npercentmap(\"total_wp\", NGA_wp)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#box-map",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-3.html#box-map",
    "title": "Hands-on_Ex08-3",
    "section": "Box map",
    "text": "Box map\nA box map extends a quartile map by adding lower and upper outlier categories, adjusting breakpoints based on whether outliers fall below or above the calculated fences.\n\nggplot(data = NGA_wp,\n       aes(x = \"\",\n           y = wp_nonfunctional)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\nCreating the boxbreaks function\nThe following R function creates 7 breakpoints for a box map by computing quartiles and fences from a vector v, using a multiplier mult (default 1.5) for the IQR.\n\nboxbreaks &lt;- function(v,mult=1.5) {\n  qv &lt;- unname(quantile(v))\n  iqr &lt;- qv[4] - qv[2]\n  upfence &lt;- qv[4] + mult * iqr\n  lofence &lt;- qv[2] - mult * iqr\n  # initialize break points vector\n  bb &lt;- vector(mode=\"numeric\",length=7)\n  # logic for lower and upper fences\n  if (lofence &lt; qv[1]) {  # no lower outliers\n    bb[1] &lt;- lofence\n    bb[2] &lt;- floor(qv[1])\n  } else {\n    bb[2] &lt;- lofence\n    bb[1] &lt;- qv[1]\n  }\n  if (upfence &gt; qv[5]) { # no upper outliers\n    bb[7] &lt;- upfence\n    bb[6] &lt;- ceiling(qv[5])\n  } else {\n    bb[6] &lt;- upfence\n    bb[7] &lt;- qv[5]\n  }\n  bb[3:5] &lt;- qv[2:4]\n  return(bb)\n}\n\n\n\nCreating the get.var function\nThe get.var function extracts a variable (given as a string) from an sf data frame and returns it as an unnamed vector.\n\nget.var &lt;- function(vname,df) {\n  v &lt;- df[vname] %&gt;% st_set_geometry(NULL)\n  v &lt;- unname(v[,1])\n  return(v)\n}\n\n\n\nTest drive the newly created function\nLet’s test the newly created function\n\nvar &lt;- get.var(\"wp_nonfunctional\", NGA_wp) \nboxbreaks(var)\n\n[1] -56.5   0.0  14.0  34.0  61.0 131.5 278.0\n\n\n\n\nBoxmap function\nThe following R function creates a box map from an sf polygon layer using a specified variable, with customizable legend title, map title, and IQR multiplier, and returns a tmap object.\n\nboxmap &lt;- function(vnam, df, \n                   legtitle=NA,\n                   mtitle=\"Box Map\",\n                   mult=1.5){\n  var &lt;- get.var(vnam,df)\n  bb &lt;- boxbreaks(var)\n  tm_shape(df) +\n    tm_polygons() +\n  tm_shape(df) +\n     tm_fill(vnam,title=legtitle,\n             breaks=bb,\n             palette=\"Blues\",\n          labels = c(\"lower outlier\", \n                     \"&lt; 25%\", \n                     \"25% - 50%\", \n                     \"50% - 75%\",\n                     \"&gt; 75%\", \n                     \"upper outlier\"))  +\n  tm_borders() +\n  tm_layout(main.title = mtitle, \n            title.position = c(\"left\",\n                               \"top\"))\n}\n\n\ntmap_mode(\"plot\")\nboxmap(\"wp_nonfunctional\", NGA_wp)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html",
    "title": "Hands-on_Ex09-5",
    "section": "",
    "text": "pacman::p_load(treemap, treemapify, tidyverse) \n\n\n\n\nThis dataset provides information of private property transaction records in 2018. The dataset is extracted from REALIS portal (https://spring.ura.gov.sg/lad/ore/login/index.cfm) of Urban Redevelopment Authority (URA).\n\n\nIn the code chunk below, read_csv() of readr is used to import realis2018.csv into R and parsed it into tibble R data.frame format.\n\nrealis2018 &lt;- read_csv(\"data/realis2018.csv\")\n\n\n\n\nThe data.frame realis2018 is in trasaction record form, which is highly disaggregated and not appropriate to be used to plot a treemap. In this section, we will perform the following steps to manipulate and prepare a data.frtame that is appropriate for treemap visualisation:\ngroup transaction records by Project Name, Planning Region, Planning Area, Property Type and Type of Sale, and compute Total Unit Sold, Total Area, Median Unit Price and Median Transacted Price by applying appropriate summary statistics on No. of Units, Area (sqm), Unit Price ($ psm) and Transacted Price ($) respectively.\nGrouping affects the verbs as follows:\n\ngrouped select() is the same as ungrouped select(), except that grouping variables are always retained.\ngrouped arrange() is the same as ungrouped; unless you set .by_group = TRUE, in which case it orders first by the grouping variables.\nmutate() and filter() are most useful in conjunction with window functions (like rank(), or min(x) == x). They are described in detail in vignette(“window-functions”).\nsample_n() and sample_frac() sample the specified number/fraction of rows in each group.\nsummarise() computes the summary for each group.\n\n\n\n\nThe code chank below shows a typical two lines code approach to perform the steps.\n\nrealis2018_grouped &lt;- group_by(realis2018, `Project Name`,\n                               `Planning Region`, `Planning Area`, \n                               `Property Type`, `Type of Sale`)\nrealis2018_summarised &lt;- summarise(realis2018_grouped, \n                          `Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE),\n                          `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n                          `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE), \n                          `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n\n\n\n\nThe code chunk below shows a more efficient way to tackle the same processes by using the pipe, %&gt;%:\n\nrealis2018_summarised &lt;- realis2018 %&gt;% \n  group_by(`Project Name`,`Planning Region`, \n           `Planning Area`, `Property Type`, \n           `Type of Sale`) %&gt;%\n  summarise(`Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE), \n            `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n            `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE),\n            `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n\n\n\n\n\ntreemap package is a R package specially designed to offer great flexibility in drawing treemaps. The core function, namely: treemap() offers at least 43 arguments. In this section, we will only explore the major arguments for designing elegent and yet truthful treemaps.\n\n\nIn this section, treemap() of Treemap package is used to plot a treemap showing the distribution of median unit prices and total unit sold of resale condominium by geographic hierarchy in 2017.\n\nrealis2018_selected &lt;- realis2018_summarised %&gt;%\n  filter(`Property Type` == \"Condominium\", `Type of Sale` == \"Resale\")\n\n\n\n\nThe code chunk below designed a treemap by using three core arguments of treemap(), namely: index, vSize and vColor.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nIn the code chunk below, type argument is define as value.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type = \"value\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nThere are two arguments that determine the mapping to color palettes: mapping and palette. The only difference between “value” and “manual” is the default value for mapping. The “value” treemap considers palette to be a diverging color palette (say ColorBrewer’s “RdYlBu”), and maps it in such a way that 0 corresponds to the middle color (typically white or yellow), -max(abs(values)) to the left-end color, and max(abs(values)), to the right-end color. The “manual” treemap simply maps min(values) to the left-end color, max(values) to the right-end color, and mean(range(values)) to the middle color.\n\n\n\nThe code chunk below shows a value type treemap.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nThe “manual” type does not interpret the values as the “value” type does. Instead, the value range is mapped linearly to the colour palette.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\nThe colour scheme used is very copnfusing. This is because mapping = (min(values), mean(range(values)), max(values)). It is not wise to use diverging colour palette such as RdYlBu if the values are all positive or negative\n\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\ntreemap() supports two popular treemap layouts, namely: “squarified” and “pivotSize”. The default is “pivotSize”.\nThe squarified treemap algorithm (Bruls et al., 2000) produces good aspect ratios, but ignores the sorting order of the rectangles (sortID). The ordered treemap, pivot-by-size, algorithm (Bederson et al., 2002) takes the sorting order (sortID) into account while aspect ratios are still acceptable.\n\n\n\nThe code chunk below plots a squarified treemap by changing the algorithm argument.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"squarified\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nWhen “pivotSize” algorithm is used, sortID argument can be used to dertemine the order in which the rectangles are placed from top left to bottom right.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"pivotSize\",\n        sortID = \"Median Transacted Price\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\n\ntreemapify is a R package specially developed to draw treemaps in ggplot2. In this section, you will learn how to designing treemps closely resemble treemaps designing in previous section by using treemapify.\n\n\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`),\n       layout = \"scol\",\n       start = \"bottomleft\") + \n  geom_treemap() +\n  scale_fill_gradient(low = \"light blue\", high = \"blue\")\n\n\n\n\n\n\n\n\n\n\n\nGroup by Planning Region\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`),\n       start = \"topleft\") + \n  geom_treemap()\n\n\n\n\n\n\n\n\nGroup by Planning Area\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap()\n\n\n\n\n\n\n\n\nAdding boundary line\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap() +\n  geom_treemap_subgroup2_border(colour = \"gray40\",\n                                size = 2) +\n  geom_treemap_subgroup_border(colour = \"gray20\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis slide shows you how to install a R package which is not available in cran.\n\nlibrary(devtools)\ninstall_github(\"timelyportfolio/d3treeR\")\nlibrary(d3treeR)\n\n\n\n\nThe codes below perform two processes.\ntreemap() is used to build a treemap by using selected variables in condominium data.frame. The treemap created is save as object called tm.\n\ntm &lt;- treemap(realis2018_summarised,\n        index=c(\"Planning Region\", \"Planning Area\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        title=\"Private Residential Property Sold, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThen d3tree() is used to build an interactive treemap.\n\nd3tree(tm,rootname = \"Singapore\" )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#installing-and-launching-r-packages",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#installing-and-launching-r-packages",
    "title": "Hands-on_Ex09-5",
    "section": "",
    "text": "pacman::p_load(treemap, treemapify, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#data-wrangling",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#data-wrangling",
    "title": "Hands-on_Ex09-5",
    "section": "",
    "text": "This dataset provides information of private property transaction records in 2018. The dataset is extracted from REALIS portal (https://spring.ura.gov.sg/lad/ore/login/index.cfm) of Urban Redevelopment Authority (URA).\n\n\nIn the code chunk below, read_csv() of readr is used to import realis2018.csv into R and parsed it into tibble R data.frame format.\n\nrealis2018 &lt;- read_csv(\"data/realis2018.csv\")\n\n\n\n\nThe data.frame realis2018 is in trasaction record form, which is highly disaggregated and not appropriate to be used to plot a treemap. In this section, we will perform the following steps to manipulate and prepare a data.frtame that is appropriate for treemap visualisation:\ngroup transaction records by Project Name, Planning Region, Planning Area, Property Type and Type of Sale, and compute Total Unit Sold, Total Area, Median Unit Price and Median Transacted Price by applying appropriate summary statistics on No. of Units, Area (sqm), Unit Price ($ psm) and Transacted Price ($) respectively.\nGrouping affects the verbs as follows:\n\ngrouped select() is the same as ungrouped select(), except that grouping variables are always retained.\ngrouped arrange() is the same as ungrouped; unless you set .by_group = TRUE, in which case it orders first by the grouping variables.\nmutate() and filter() are most useful in conjunction with window functions (like rank(), or min(x) == x). They are described in detail in vignette(“window-functions”).\nsample_n() and sample_frac() sample the specified number/fraction of rows in each group.\nsummarise() computes the summary for each group.\n\n\n\n\nThe code chank below shows a typical two lines code approach to perform the steps.\n\nrealis2018_grouped &lt;- group_by(realis2018, `Project Name`,\n                               `Planning Region`, `Planning Area`, \n                               `Property Type`, `Type of Sale`)\nrealis2018_summarised &lt;- summarise(realis2018_grouped, \n                          `Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE),\n                          `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n                          `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE), \n                          `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))\n\n\n\n\nThe code chunk below shows a more efficient way to tackle the same processes by using the pipe, %&gt;%:\n\nrealis2018_summarised &lt;- realis2018 %&gt;% \n  group_by(`Project Name`,`Planning Region`, \n           `Planning Area`, `Property Type`, \n           `Type of Sale`) %&gt;%\n  summarise(`Total Unit Sold` = sum(`No. of Units`, na.rm = TRUE), \n            `Total Area` = sum(`Area (sqm)`, na.rm = TRUE),\n            `Median Unit Price ($ psm)` = median(`Unit Price ($ psm)`, na.rm = TRUE),\n            `Median Transacted Price` = median(`Transacted Price ($)`, na.rm = TRUE))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#designing-treemap-with-treemap-package",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#designing-treemap-with-treemap-package",
    "title": "Hands-on_Ex09-5",
    "section": "",
    "text": "treemap package is a R package specially designed to offer great flexibility in drawing treemaps. The core function, namely: treemap() offers at least 43 arguments. In this section, we will only explore the major arguments for designing elegent and yet truthful treemaps.\n\n\nIn this section, treemap() of Treemap package is used to plot a treemap showing the distribution of median unit prices and total unit sold of resale condominium by geographic hierarchy in 2017.\n\nrealis2018_selected &lt;- realis2018_summarised %&gt;%\n  filter(`Property Type` == \"Condominium\", `Type of Sale` == \"Resale\")\n\n\n\n\nThe code chunk below designed a treemap by using three core arguments of treemap(), namely: index, vSize and vColor.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nIn the code chunk below, type argument is define as value.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type = \"value\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nThere are two arguments that determine the mapping to color palettes: mapping and palette. The only difference between “value” and “manual” is the default value for mapping. The “value” treemap considers palette to be a diverging color palette (say ColorBrewer’s “RdYlBu”), and maps it in such a way that 0 corresponds to the middle color (typically white or yellow), -max(abs(values)) to the left-end color, and max(abs(values)), to the right-end color. The “manual” treemap simply maps min(values) to the left-end color, max(values) to the right-end color, and mean(range(values)) to the middle color.\n\n\n\nThe code chunk below shows a value type treemap.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nThe “manual” type does not interpret the values as the “value” type does. Instead, the value range is mapped linearly to the colour palette.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"RdYlBu\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\nThe colour scheme used is very copnfusing. This is because mapping = (min(values), mean(range(values)), max(values)). It is not wise to use diverging colour palette such as RdYlBu if the values are all positive or negative\n\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\ntreemap() supports two popular treemap layouts, namely: “squarified” and “pivotSize”. The default is “pivotSize”.\nThe squarified treemap algorithm (Bruls et al., 2000) produces good aspect ratios, but ignores the sorting order of the rectangles (sortID). The ordered treemap, pivot-by-size, algorithm (Bederson et al., 2002) takes the sorting order (sortID) into account while aspect ratios are still acceptable.\n\n\n\nThe code chunk below plots a squarified treemap by changing the algorithm argument.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"squarified\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\n\n\n\nWhen “pivotSize” algorithm is used, sortID argument can be used to dertemine the order in which the rectangles are placed from top left to bottom right.\n\ntreemap(realis2018_selected,\n        index=c(\"Planning Region\", \"Planning Area\", \"Project Name\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"manual\",\n        palette=\"Blues\", \n        algorithm = \"pivotSize\",\n        sortID = \"Median Transacted Price\",\n        title=\"Resale Condominium by Planning Region and Area, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#designing-treemap-using-treemapify-package",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#designing-treemap-using-treemapify-package",
    "title": "Hands-on_Ex09-5",
    "section": "",
    "text": "treemapify is a R package specially developed to draw treemaps in ggplot2. In this section, you will learn how to designing treemps closely resemble treemaps designing in previous section by using treemapify.\n\n\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`),\n       layout = \"scol\",\n       start = \"bottomleft\") + \n  geom_treemap() +\n  scale_fill_gradient(low = \"light blue\", high = \"blue\")\n\n\n\n\n\n\n\n\n\n\n\nGroup by Planning Region\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`),\n       start = \"topleft\") + \n  geom_treemap()\n\n\n\n\n\n\n\n\nGroup by Planning Area\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap()\n\n\n\n\n\n\n\n\nAdding boundary line\n\nggplot(data=realis2018_selected, \n       aes(area = `Total Unit Sold`,\n           fill = `Median Unit Price ($ psm)`,\n           subgroup = `Planning Region`,\n           subgroup2 = `Planning Area`)) + \n  geom_treemap() +\n  geom_treemap_subgroup2_border(colour = \"gray40\",\n                                size = 2) +\n  geom_treemap_subgroup_border(colour = \"gray20\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#designing-interactive-treemap-using-d3treer",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-5.html#designing-interactive-treemap-using-d3treer",
    "title": "Hands-on_Ex09-5",
    "section": "",
    "text": "This slide shows you how to install a R package which is not available in cran.\n\nlibrary(devtools)\ninstall_github(\"timelyportfolio/d3treeR\")\nlibrary(d3treeR)\n\n\n\n\nThe codes below perform two processes.\ntreemap() is used to build a treemap by using selected variables in condominium data.frame. The treemap created is save as object called tm.\n\ntm &lt;- treemap(realis2018_summarised,\n        index=c(\"Planning Region\", \"Planning Area\"),\n        vSize=\"Total Unit Sold\",\n        vColor=\"Median Unit Price ($ psm)\",\n        type=\"value\",\n        title=\"Private Residential Property Sold, 2017\",\n        title.legend = \"Median Unit Price (S$ per sq. m)\"\n        )\n\n\n\n\n\n\n\n\nThen d3tree() is used to build an interactive treemap.\n\nd3tree(tm,rootname = \"Singapore\" )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html",
    "title": "Hands-on_Ex09-3",
    "section": "",
    "text": "pacman::p_load(seriation, dendextend, heatmaply, tidyverse)\n\n\n\n\n\n\n\nwh &lt;- read_csv(\"data/WHData-2018.csv\")\n\n\n\n\nWe need to change the rows by country name instead of row number by using the code chunk below\n\nrow.names(wh) &lt;- wh$Country\n\n\n\n\nThe data was loaded into a data frame, but it has to be a data matrix to make your heatmap.\nThe code chunk below will be used to transform wh data frame into a data matrix.\n\nwh1 &lt;- dplyr::select(wh, c(3, 7:12))\nwh_matrix &lt;- data.matrix(wh)\n\n\n\n\n\nThere are many R packages and functions can be used to drawing static heatmaps, they are:\n\nheatmap(): It draws a simple heatmap.\nheatmap.2() of gplots R package. It draws an enhanced heatmap compared to the R base function.\npheatmap() of pheatmap R package. pheatmap package also known as Pretty Heatmap. The package provides functions to draws pretty heatmaps and provides more control to change the appearance of heatmaps.\nComplexHeatmap package of R/Bioconductor package. The package draws, annotates and arranges complex heatmaps (very useful for genomic data analysis). The full reference guide of the package is available here.\nsuperheat package: A Graphical Tool for Exploring Complex Datasets Using Heatmaps. A system for generating extendable and customizable heatmaps for exploring complex datasets, including big data and data with multiple data types. The full reference guide of the package is available here.\n\n\n\nBy default, heatmap() plots a cluster heatmap. The arguments Rowv=NA and Colv=NA are used to switch off the option of plotting the row and column dendrograms.\n\nwh_heatmap &lt;- heatmap(wh_matrix,\n                      Rowv=NA, Colv=NA)\n\n\n\n\n\n\n\n\nTo plot a cluster heatmap, we just have to use the default as shown in the code chunk below.\n\nwh_heatmap &lt;- heatmap(wh_matrix)\n\n\n\n\n\n\n\n\nThe order of both rows and columns is different compare to the native wh_matrix. This is because heatmap do a reordering using clusterisation: it calculates the distance between each pair of rows and columns and try to order them by similarity. Moreover, the corresponding dendrogram are provided beside the heatmap.\nHere, red cells denotes small values, and red small ones. This heatmap is not really informative. Indeed, the Happiness Score variable have relatively higher values, what makes that the other variables with small values all look the same. Thus, we need to normalize this matrix. This is done using the scale argument. It can be applied to rows or to columns following your needs.\n\nwh_heatmap &lt;- heatmap(wh_matrix,\n                      scale=\"column\",\n                      cexRow = 0.6, \n                      cexCol = 0.8,\n                      margins = c(10, 4))\n\n\n\n\n\n\n\n\nNotice that the values are scaled now. Also note that margins argument is used to ensure that the entire x-axis labels are displayed completely and, cexRow and cexCol arguments are used to define the font size used for y-axis and x-axis labels respectively.\n\n\n\n\nheatmaply is an R package for building interactive cluster heatmap that can be shared online as a stand-alone HTML file.\n\n\n\nheatmaply(mtcars)\n\n\n\n\n\nThe code chunk below shows the basic syntax needed to create n interactive heatmap by using heatmaply package.\n\nheatmaply(wh_matrix[, -c(1, 2, 4, 5)])\n\n\n\n\n\nNote that:\n\nDifferent from heatmap(), for heatmaply() the default horizontal dendrogram is placed on the left hand side of the heatmap.\nThe text label of each raw, on the other hand, is placed on the right hand side of the heat map.\nWhen the x-axis marker labels are too long, they will be rotated by 135 degree from the north.\n\n\n\n\nWhen analysing multivariate data set, it is very common that the variables in the data sets includes values that reflect different types of measurement. In general, these variables’ values have their own range. In order to ensure that all the variables have comparable values, data transformation are commonly used before clustering.\nThree main data transformation methods are supported by heatmaply(), namely: scale, normalise and percentilse.\n\n\n\nWhen all variables are came from or assumed to come from some normal distribution, then scaling (i.e.: subtract the mean and divide by the standard deviation) would bring them all close to the standard normal distribution.\nIn such a case, each value would reflect the distance from the mean in units of standard deviation.\nThe scale argument in heatmaply() supports column and row scaling.\n\n\nheatmaply(wh_matrix[, -c(1, 2, 4, 5)],\n          scale = \"column\")\n\n\n\n\n\n\n\n\nWhen variables in the data comes from possibly different (and non-normal) distributions, the normalize function can be used to bring data to the 0 to 1 scale by subtracting the minimum and dividing by the maximum of all observations. This preserves the shape of each variable’s distribution while making them easily comparable on the same “scale”.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]))\n\n\n\n\n\n\n\n\n\nThis is similar to ranking the variables, but instead of keeping the rank values, divide them by the maximal rank.\nThis is done by using the ecdf of the variables on their own values, bringing each value to its empirical percentile.\nThe benefit of the percentize function is that each value has a relatively clear interpretation, it is the percent of observations that got that value or below it.\n\n\nheatmaply(percentize(wh_matrix[, -c(1, 2, 4, 5)]))\n\n\n\n\n\n\n\n\n\nIn the code chunk below, the heatmap is plotted by using hierachical clustering algorithm with “Euclidean distance” and “ward.D” method.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\")\n\n\n\n\n\n\n\n\nIn order to determine the best clustering method and number of cluster the dend_expend() and find_k() functions of dendextend package will be used.\nFirst, the dend_expend() will be used to determine the recommended clustering method to be used.\n\nwh_d &lt;- dist(normalize(wh_matrix[, -c(1, 2, 4, 5)]), method = \"euclidean\")\ndend_expend(wh_d)[[3]]\n\n  dist_methods hclust_methods     optim\n1      unknown         ward.D 0.6137851\n2      unknown        ward.D2 0.6289186\n3      unknown         single 0.4774362\n4      unknown       complete 0.6434009\n5      unknown        average 0.6701688\n6      unknown       mcquitty 0.5020102\n7      unknown         median 0.5901833\n8      unknown       centroid 0.6338734\n\n\nThe output table shows that “average” method should be used because it gave the high optimum value.\nNext, find_k() is used to determine the optimal number of cluster.\n\nwh_clust &lt;- hclust(wh_d, method = \"average\")\nnum_k &lt;- find_k(wh_clust)\nplot(num_k)\n\n\n\n\n\n\n\n\nFigure above shows that k=3 would be good.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"average\",\n          k_row = 3)\n\n\n\n\n\nOne of the problems with hierarchical clustering is that it doesn’t actually place the rows in a definite order, it merely constrains the space of possible orderings. Take three items A, B and C. If you ignore reflections, there are three possible orderings: ABC, ACB, BAC. If clustering them gives you ((A+B)+C) as a tree, you know that C can’t end up between A and B, but it doesn’t tell you which way to flip the A+B cluster. It doesn’t tell you if the ABC ordering will lead to a clearer-looking heatmap than the BAC ordering.\nheatmaply uses the seriation package to find an optimal ordering of rows and columns. Optimal means to optimize the Hamiltonian path length that is restricted by the dendrogram structure. This, in other words, means to rotate the branches so that the sum of distances between each adjacent leaf (label) will be minimized. This is related to a restricted version of the travelling salesman problem.\nHere we meet our first seriation algorithm: Optimal Leaf Ordering (OLO). This algorithm starts with the output of an agglomerative clustering algorithm and produces a unique ordering, one that flips the various branches of the dendrogram around so as to minimize the sum of dissimilarities between adjacent leaves. Here is the result of applying Optimal Leaf Ordering to the same clustering result as the heatmap above.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"OLO\")\n\n\n\n\n\nThe default options is “OLO” (Optimal leaf ordering) which optimizes the above criterion (in O(n^4)). Another option is “GW” (Gruvaeus and Wainer) which aims for the same goal but uses a potentially faster heuristic.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"GW\")\n\n\n\n\n\nThe option “mean” gives the output we would get by default from heatmap functions in other packages such as gplots::heatmap.2.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"mean\")\n\n\n\n\n\nThe option “none” gives us the dendrograms without any rotation that is based on the data matrix.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"none\")\n\n\n\n\n\n\n\n\nThe default colour palette uses by heatmaply is viridis. heatmaply users, however, can use other colour palettes in order to improve the aestheticness and visual friendliness of the heatmap.\nIn the code chunk below, the Blues colour palette of rColorBrewer is used\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"none\",\n          colors = Blues)\n\n\n\n\n\n\n\n\nBeside providing a wide collection of arguments for meeting the statistical analysis needs, heatmaply also provides many plotting features to ensure cartographic quality heatmap can be produced.\nIn the code chunk below the following arguments are used:\nk_row is used to produce 5 groups. margins is used to change the top margin to 60 and row margin to 200. fontsizw_row and fontsize_col are used to change the font size for row and column labels to 4. main is used to write the main title of the plot. xlab and ylab are used to write the x-axis and y-axis labels respectively.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          Colv=NA,\n          seriate = \"none\",\n          colors = Blues,\n          k_row = 5,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"World Happiness Score and Variables by Country, 2018 \\nDataTransformation using Normalise Method\",\n          xlab = \"World Happiness Indicators\",\n          ylab = \"World Countries\"\n          )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html#installing-and-launching-r-packages",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html#installing-and-launching-r-packages",
    "title": "Hands-on_Ex09-3",
    "section": "",
    "text": "pacman::p_load(seriation, dendextend, heatmaply, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html#importing-and-preparing-the-data-set",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html#importing-and-preparing-the-data-set",
    "title": "Hands-on_Ex09-3",
    "section": "",
    "text": "wh &lt;- read_csv(\"data/WHData-2018.csv\")\n\n\n\n\nWe need to change the rows by country name instead of row number by using the code chunk below\n\nrow.names(wh) &lt;- wh$Country\n\n\n\n\nThe data was loaded into a data frame, but it has to be a data matrix to make your heatmap.\nThe code chunk below will be used to transform wh data frame into a data matrix.\n\nwh1 &lt;- dplyr::select(wh, c(3, 7:12))\nwh_matrix &lt;- data.matrix(wh)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html#static-heatmap",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html#static-heatmap",
    "title": "Hands-on_Ex09-3",
    "section": "",
    "text": "There are many R packages and functions can be used to drawing static heatmaps, they are:\n\nheatmap(): It draws a simple heatmap.\nheatmap.2() of gplots R package. It draws an enhanced heatmap compared to the R base function.\npheatmap() of pheatmap R package. pheatmap package also known as Pretty Heatmap. The package provides functions to draws pretty heatmaps and provides more control to change the appearance of heatmaps.\nComplexHeatmap package of R/Bioconductor package. The package draws, annotates and arranges complex heatmaps (very useful for genomic data analysis). The full reference guide of the package is available here.\nsuperheat package: A Graphical Tool for Exploring Complex Datasets Using Heatmaps. A system for generating extendable and customizable heatmaps for exploring complex datasets, including big data and data with multiple data types. The full reference guide of the package is available here.\n\n\n\nBy default, heatmap() plots a cluster heatmap. The arguments Rowv=NA and Colv=NA are used to switch off the option of plotting the row and column dendrograms.\n\nwh_heatmap &lt;- heatmap(wh_matrix,\n                      Rowv=NA, Colv=NA)\n\n\n\n\n\n\n\n\nTo plot a cluster heatmap, we just have to use the default as shown in the code chunk below.\n\nwh_heatmap &lt;- heatmap(wh_matrix)\n\n\n\n\n\n\n\n\nThe order of both rows and columns is different compare to the native wh_matrix. This is because heatmap do a reordering using clusterisation: it calculates the distance between each pair of rows and columns and try to order them by similarity. Moreover, the corresponding dendrogram are provided beside the heatmap.\nHere, red cells denotes small values, and red small ones. This heatmap is not really informative. Indeed, the Happiness Score variable have relatively higher values, what makes that the other variables with small values all look the same. Thus, we need to normalize this matrix. This is done using the scale argument. It can be applied to rows or to columns following your needs.\n\nwh_heatmap &lt;- heatmap(wh_matrix,\n                      scale=\"column\",\n                      cexRow = 0.6, \n                      cexCol = 0.8,\n                      margins = c(10, 4))\n\n\n\n\n\n\n\n\nNotice that the values are scaled now. Also note that margins argument is used to ensure that the entire x-axis labels are displayed completely and, cexRow and cexCol arguments are used to define the font size used for y-axis and x-axis labels respectively."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html#creating-interactive-heatmap",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-3.html#creating-interactive-heatmap",
    "title": "Hands-on_Ex09-3",
    "section": "",
    "text": "heatmaply is an R package for building interactive cluster heatmap that can be shared online as a stand-alone HTML file.\n\n\n\nheatmaply(mtcars)\n\n\n\n\n\nThe code chunk below shows the basic syntax needed to create n interactive heatmap by using heatmaply package.\n\nheatmaply(wh_matrix[, -c(1, 2, 4, 5)])\n\n\n\n\n\nNote that:\n\nDifferent from heatmap(), for heatmaply() the default horizontal dendrogram is placed on the left hand side of the heatmap.\nThe text label of each raw, on the other hand, is placed on the right hand side of the heat map.\nWhen the x-axis marker labels are too long, they will be rotated by 135 degree from the north.\n\n\n\n\nWhen analysing multivariate data set, it is very common that the variables in the data sets includes values that reflect different types of measurement. In general, these variables’ values have their own range. In order to ensure that all the variables have comparable values, data transformation are commonly used before clustering.\nThree main data transformation methods are supported by heatmaply(), namely: scale, normalise and percentilse.\n\n\n\nWhen all variables are came from or assumed to come from some normal distribution, then scaling (i.e.: subtract the mean and divide by the standard deviation) would bring them all close to the standard normal distribution.\nIn such a case, each value would reflect the distance from the mean in units of standard deviation.\nThe scale argument in heatmaply() supports column and row scaling.\n\n\nheatmaply(wh_matrix[, -c(1, 2, 4, 5)],\n          scale = \"column\")\n\n\n\n\n\n\n\n\nWhen variables in the data comes from possibly different (and non-normal) distributions, the normalize function can be used to bring data to the 0 to 1 scale by subtracting the minimum and dividing by the maximum of all observations. This preserves the shape of each variable’s distribution while making them easily comparable on the same “scale”.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]))\n\n\n\n\n\n\n\n\n\nThis is similar to ranking the variables, but instead of keeping the rank values, divide them by the maximal rank.\nThis is done by using the ecdf of the variables on their own values, bringing each value to its empirical percentile.\nThe benefit of the percentize function is that each value has a relatively clear interpretation, it is the percent of observations that got that value or below it.\n\n\nheatmaply(percentize(wh_matrix[, -c(1, 2, 4, 5)]))\n\n\n\n\n\n\n\n\n\nIn the code chunk below, the heatmap is plotted by using hierachical clustering algorithm with “Euclidean distance” and “ward.D” method.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"ward.D\")\n\n\n\n\n\n\n\n\nIn order to determine the best clustering method and number of cluster the dend_expend() and find_k() functions of dendextend package will be used.\nFirst, the dend_expend() will be used to determine the recommended clustering method to be used.\n\nwh_d &lt;- dist(normalize(wh_matrix[, -c(1, 2, 4, 5)]), method = \"euclidean\")\ndend_expend(wh_d)[[3]]\n\n  dist_methods hclust_methods     optim\n1      unknown         ward.D 0.6137851\n2      unknown        ward.D2 0.6289186\n3      unknown         single 0.4774362\n4      unknown       complete 0.6434009\n5      unknown        average 0.6701688\n6      unknown       mcquitty 0.5020102\n7      unknown         median 0.5901833\n8      unknown       centroid 0.6338734\n\n\nThe output table shows that “average” method should be used because it gave the high optimum value.\nNext, find_k() is used to determine the optimal number of cluster.\n\nwh_clust &lt;- hclust(wh_d, method = \"average\")\nnum_k &lt;- find_k(wh_clust)\nplot(num_k)\n\n\n\n\n\n\n\n\nFigure above shows that k=3 would be good.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          dist_method = \"euclidean\",\n          hclust_method = \"average\",\n          k_row = 3)\n\n\n\n\n\nOne of the problems with hierarchical clustering is that it doesn’t actually place the rows in a definite order, it merely constrains the space of possible orderings. Take three items A, B and C. If you ignore reflections, there are three possible orderings: ABC, ACB, BAC. If clustering them gives you ((A+B)+C) as a tree, you know that C can’t end up between A and B, but it doesn’t tell you which way to flip the A+B cluster. It doesn’t tell you if the ABC ordering will lead to a clearer-looking heatmap than the BAC ordering.\nheatmaply uses the seriation package to find an optimal ordering of rows and columns. Optimal means to optimize the Hamiltonian path length that is restricted by the dendrogram structure. This, in other words, means to rotate the branches so that the sum of distances between each adjacent leaf (label) will be minimized. This is related to a restricted version of the travelling salesman problem.\nHere we meet our first seriation algorithm: Optimal Leaf Ordering (OLO). This algorithm starts with the output of an agglomerative clustering algorithm and produces a unique ordering, one that flips the various branches of the dendrogram around so as to minimize the sum of dissimilarities between adjacent leaves. Here is the result of applying Optimal Leaf Ordering to the same clustering result as the heatmap above.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"OLO\")\n\n\n\n\n\nThe default options is “OLO” (Optimal leaf ordering) which optimizes the above criterion (in O(n^4)). Another option is “GW” (Gruvaeus and Wainer) which aims for the same goal but uses a potentially faster heuristic.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"GW\")\n\n\n\n\n\nThe option “mean” gives the output we would get by default from heatmap functions in other packages such as gplots::heatmap.2.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"mean\")\n\n\n\n\n\nThe option “none” gives us the dendrograms without any rotation that is based on the data matrix.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"none\")\n\n\n\n\n\n\n\n\nThe default colour palette uses by heatmaply is viridis. heatmaply users, however, can use other colour palettes in order to improve the aestheticness and visual friendliness of the heatmap.\nIn the code chunk below, the Blues colour palette of rColorBrewer is used\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          seriate = \"none\",\n          colors = Blues)\n\n\n\n\n\n\n\n\nBeside providing a wide collection of arguments for meeting the statistical analysis needs, heatmaply also provides many plotting features to ensure cartographic quality heatmap can be produced.\nIn the code chunk below the following arguments are used:\nk_row is used to produce 5 groups. margins is used to change the top margin to 60 and row margin to 200. fontsizw_row and fontsize_col are used to change the font size for row and column labels to 4. main is used to write the main title of the plot. xlab and ylab are used to write the x-axis and y-axis labels respectively.\n\nheatmaply(normalize(wh_matrix[, -c(1, 2, 4, 5)]),\n          Colv=NA,\n          seriate = \"none\",\n          colors = Blues,\n          k_row = 5,\n          margins = c(NA,200,60,NA),\n          fontsize_row = 4,\n          fontsize_col = 5,\n          main=\"World Happiness Score and Variables by Country, 2018 \\nDataTransformation using Normalise Method\",\n          xlab = \"World Happiness Indicators\",\n          ylab = \"World Countries\"\n          )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#reviewing-the-imported-data",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#reviewing-the-imported-data",
    "title": "Hands-on_Ex05",
    "section": "2.1 Reviewing the imported data",
    "text": "2.1 Reviewing the imported data\n\nglimpse(GAStech_edges)\n\nRows: 9,063\nColumns: 8\n$ source      &lt;dbl&gt; 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 26, 26, 26…\n$ target      &lt;dbl&gt; 41, 40, 51, 52, 53, 45, 44, 46, 48, 49, 47, 54, 27, 28, 29…\n$ SentDate    &lt;chr&gt; \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\"…\n$ SentTime    &lt;time&gt; 08:39:00, 08:39:00, 08:58:00, 08:58:00, 08:58:00, 08:58:0…\n$ Subject     &lt;chr&gt; \"GT-SeismicProcessorPro Bug Report\", \"GT-SeismicProcessorP…\n$ MainSubject &lt;chr&gt; \"Work related\", \"Work related\", \"Work related\", \"Work rela…\n$ sourceLabel &lt;chr&gt; \"Sven.Flecha\", \"Sven.Flecha\", \"Kanon.Herrero\", \"Kanon.Herr…\n$ targetLabel &lt;chr&gt; \"Isak.Baza\", \"Lucas.Alcazar\", \"Felix.Resumir\", \"Hideki.Coc…"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#wrangling-time",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#wrangling-time",
    "title": "Hands-on_Ex05",
    "section": "2.2 Wrangling time",
    "text": "2.2 Wrangling time\n\nGAStech_edges &lt;- GAStech_edges %&gt;%\n  mutate(SendDate = dmy(SentDate)) %&gt;%\n  mutate(Weekday = wday(SentDate, label = TRUE, abbr = FALSE))\n\n\n2.2.1 Reviewing the revised data fields\n\nglimpse(GAStech_edges)\n\nRows: 9,063\nColumns: 10\n$ source      &lt;dbl&gt; 43, 43, 44, 44, 44, 44, 44, 44, 44, 44, 44, 44, 26, 26, 26…\n$ target      &lt;dbl&gt; 41, 40, 51, 52, 53, 45, 44, 46, 48, 49, 47, 54, 27, 28, 29…\n$ SentDate    &lt;chr&gt; \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\", \"6/1/2014\"…\n$ SentTime    &lt;time&gt; 08:39:00, 08:39:00, 08:58:00, 08:58:00, 08:58:00, 08:58:0…\n$ Subject     &lt;chr&gt; \"GT-SeismicProcessorPro Bug Report\", \"GT-SeismicProcessorP…\n$ MainSubject &lt;chr&gt; \"Work related\", \"Work related\", \"Work related\", \"Work rela…\n$ sourceLabel &lt;chr&gt; \"Sven.Flecha\", \"Sven.Flecha\", \"Kanon.Herrero\", \"Kanon.Herr…\n$ targetLabel &lt;chr&gt; \"Isak.Baza\", \"Lucas.Alcazar\", \"Felix.Resumir\", \"Hideki.Coc…\n$ SendDate    &lt;date&gt; 2014-01-06, 2014-01-06, 2014-01-06, 2014-01-06, 2014-01-0…\n$ Weekday     &lt;ord&gt; Friday, Friday, Friday, Friday, Friday, Friday, Friday, Fr…"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#wrangling-attributes",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#wrangling-attributes",
    "title": "Hands-on_Ex05",
    "section": "2.3 Wrangling attributes",
    "text": "2.3 Wrangling attributes\n\nGAStech_edges_aggregated &lt;- GAStech_edges %&gt;%\n  filter(MainSubject == \"Work related\") %&gt;%\n  group_by(source, target, Weekday) %&gt;%\n    summarise(Weight = n()) %&gt;%\n  filter(source!=target) %&gt;%\n  filter(Weight &gt; 1) %&gt;%\n  ungroup()\n\n\n2.3.1 Reviewing the revised edges file\n\nglimpse(GAStech_edges_aggregated)\n\nRows: 1,372\nColumns: 4\n$ source  &lt;dbl&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ target  &lt;dbl&gt; 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 6,…\n$ Weekday &lt;ord&gt; Sunday, Monday, Tuesday, Wednesday, Friday, Sunday, Monday, Tu…\n$ Weight  &lt;int&gt; 5, 2, 3, 4, 6, 5, 2, 3, 4, 6, 5, 2, 3, 4, 6, 5, 2, 3, 4, 6, 5,…"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#the-tbl_graph-object",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#the-tbl_graph-object",
    "title": "Hands-on_Ex05",
    "section": "3.1 The tbl_graph object",
    "text": "3.1 The tbl_graph object\n\ntbl_graph() creates a tbl_graph network object from nodes and edges data.\nas_tbl_graph() converts network data and objects to a tbl_graph network. Below are network data and objects supported by as_tbl_graph()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#the-dplyr-verbs-in-tidygraph",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#the-dplyr-verbs-in-tidygraph",
    "title": "Hands-on_Ex05",
    "section": "3.2 THe dplyr verbs in tidygraph",
    "text": "3.2 THe dplyr verbs in tidygraph\n\nactivate() verb from tidygraph serves as a switch between tibbles for nodes and edges. All dplyr verbs applied to tbl_graph object are applied to the active tibble."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#using-tbl_graph-to-build-tidygraph-data-model.",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#using-tbl_graph-to-build-tidygraph-data-model.",
    "title": "Hands-on_Ex05",
    "section": "3.3 Using tbl_graph() to build tidygraph data model.",
    "text": "3.3 Using tbl_graph() to build tidygraph data model.\n\nGAStech_graph &lt;- tbl_graph(nodes = GAStech_nodes,\n                           edges = GAStech_edges_aggregated, \n                           directed = TRUE)\n\n\n3.3.1 Reviewing the output tidygraph’s graph object\n\nGAStech_graph\n\n# A tbl_graph: 54 nodes and 1372 edges\n#\n# A directed multigraph with 1 component\n#\n# Node Data: 54 × 4 (active)\n      id label               Department     Title                               \n   &lt;dbl&gt; &lt;chr&gt;               &lt;chr&gt;          &lt;chr&gt;                               \n 1     1 Mat.Bramar          Administration Assistant to CEO                    \n 2     2 Anda.Ribera         Administration Assistant to CFO                    \n 3     3 Rachel.Pantanal     Administration Assistant to CIO                    \n 4     4 Linda.Lagos         Administration Assistant to COO                    \n 5     5 Ruscella.Mies.Haber Administration Assistant to Engineering Group Mana…\n 6     6 Carla.Forluniau     Administration Assistant to IT Group Manager       \n 7     7 Cornelia.Lais       Administration Assistant to Security Group Manager \n 8    44 Kanon.Herrero       Security       Badging Office                      \n 9    45 Varja.Lagos         Security       Badging Office                      \n10    46 Stenig.Fusil        Security       Building Control                    \n# ℹ 44 more rows\n#\n# Edge Data: 1,372 × 4\n   from    to Weekday Weight\n  &lt;int&gt; &lt;int&gt; &lt;ord&gt;    &lt;int&gt;\n1     1     2 Sunday       5\n2     1     2 Monday       2\n3     1     2 Tuesday      3\n# ℹ 1,369 more rows"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#reviewing-the-output-tidygraphs-graph-object-1",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#reviewing-the-output-tidygraphs-graph-object-1",
    "title": "Hands-on_Ex05",
    "section": "3.4 Reviewing the output tidygraph’s graph object",
    "text": "3.4 Reviewing the output tidygraph’s graph object\n\nThe output above reveals that GAStech_graph is a tbl_graph object with 54 nodes and 4541 edges.\nThe command also prints the first six rows of “Node Data” and the first three of “Edge Data”.\nIt states that the Node Data is active. The notion of an active tibble within a tbl_graph object makes it possible to manipulate the data in one tibble at a time."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#changing-the-active-object",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#changing-the-active-object",
    "title": "Hands-on_Ex05",
    "section": "3.5 Changing the active object",
    "text": "3.5 Changing the active object\n\nGAStech_graph %&gt;%\n  activate(edges) %&gt;%\n  arrange(desc(Weight))\n\n# A tbl_graph: 54 nodes and 1372 edges\n#\n# A directed multigraph with 1 component\n#\n# Edge Data: 1,372 × 4 (active)\n    from    to Weekday   Weight\n   &lt;int&gt; &lt;int&gt; &lt;ord&gt;      &lt;int&gt;\n 1    40    41 Saturday      13\n 2    41    43 Monday        11\n 3    35    31 Tuesday       10\n 4    40    41 Monday        10\n 5    40    43 Monday        10\n 6    36    32 Sunday         9\n 7    40    43 Saturday       9\n 8    41    40 Monday         9\n 9    19    15 Wednesday      8\n10    35    38 Tuesday        8\n# ℹ 1,362 more rows\n#\n# Node Data: 54 × 4\n     id label           Department     Title           \n  &lt;dbl&gt; &lt;chr&gt;           &lt;chr&gt;          &lt;chr&gt;           \n1     1 Mat.Bramar      Administration Assistant to CEO\n2     2 Anda.Ribera     Administration Assistant to CFO\n3     3 Rachel.Pantanal Administration Assistant to CIO\n# ℹ 51 more rows"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#plotting-a-basic-network-graph",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#plotting-a-basic-network-graph",
    "title": "Hands-on_Ex05",
    "section": "4.1 Plotting a basic network graph",
    "text": "4.1 Plotting a basic network graph\n\nggraph(GAStech_graph) +\n  geom_edge_link() +\n  geom_node_point()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#changing-the-default-network-graph-theme",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#changing-the-default-network-graph-theme",
    "title": "Hands-on_Ex05",
    "section": "4.2 Changing the default network graph theme",
    "text": "4.2 Changing the default network graph theme\n\ng &lt;- ggraph(GAStech_graph) + \n  geom_edge_link(aes()) +\n  geom_node_point(aes())\n\ng + theme_graph()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#changing-the-coloring-of-the-plot",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#changing-the-coloring-of-the-plot",
    "title": "Hands-on_Ex05",
    "section": "4.3 Changing the coloring of the plot",
    "text": "4.3 Changing the coloring of the plot\n\ng &lt;- ggraph(GAStech_graph) + \n  geom_edge_link(aes(colour = 'grey50')) +\n  geom_node_point(aes(colour = 'grey40'))\n\ng + theme_graph(background = 'grey10',\n                text_colour = 'white')"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#fruchterman-and-reingold-layout",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#fruchterman-and-reingold-layout",
    "title": "Hands-on_Ex05",
    "section": "4.4 Fruchterman and Reingold layout",
    "text": "4.4 Fruchterman and Reingold layout\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"fr\") +\n  geom_edge_link(aes()) +\n  geom_node_point(aes())\n\ng + theme_graph()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#modifying-network-nodes",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#modifying-network-nodes",
    "title": "Hands-on_Ex05",
    "section": "4.5 Modifying network nodes",
    "text": "4.5 Modifying network nodes\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes()) +\n  geom_node_point(aes(colour = Department, \n                      size = 3))\n\ng + theme_graph()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#modifying-edges",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#modifying-edges",
    "title": "Hands-on_Ex05",
    "section": "4.6 Modifying edges",
    "text": "4.6 Modifying edges\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") +\n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 3)\n\ng + theme_graph()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-facet_edges",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-facet_edges",
    "title": "Hands-on_Ex05",
    "section": "5.1 Working with facet_edges()",
    "text": "5.1 Working with facet_edges()\n\nset_graph_style()\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2)\n\ng + facet_edges(~Weekday)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-facet_edges-1",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-facet_edges-1",
    "title": "Hands-on_Ex05",
    "section": "5.2 Working with facet_edges()",
    "text": "5.2 Working with facet_edges()\n\nset_graph_style()\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2) +\n  theme(legend.position = 'bottom')\n  \ng + facet_edges(~Weekday)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#a-framed-facet-graph",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#a-framed-facet-graph",
    "title": "Hands-on_Ex05",
    "section": "5.3 A framed facet graph",
    "text": "5.3 A framed facet graph\n\nset_graph_style() \n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2)\n  \ng + facet_edges(~Weekday) +\n  th_foreground(foreground = \"grey80\",  \n                border = TRUE) +\n  theme(legend.position = 'bottom')"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#wroking-with-facet_nodes",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#wroking-with-facet_nodes",
    "title": "Hands-on_Ex05",
    "section": "5.4 Wroking with facet_nodes()",
    "text": "5.4 Wroking with facet_nodes()\n\nset_graph_style()\n\ng &lt;- ggraph(GAStech_graph, \n            layout = \"nicely\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department), \n                  size = 2)\n  \ng + facet_nodes(~Department)+\n  th_foreground(foreground = \"grey80\",  \n                border = TRUE) +\n  theme(legend.position = 'bottom')"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#computing-centrality-indices",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#computing-centrality-indices",
    "title": "Hands-on_Ex05",
    "section": "6.1 Computing centrality indices",
    "text": "6.1 Computing centrality indices\n\ng &lt;- GAStech_graph %&gt;%\n  mutate(betweenness_centrality = centrality_betweenness()) %&gt;%\n  ggraph(layout = \"fr\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department,\n            size=betweenness_centrality))\ng + theme_graph()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#visualising-network-metrics",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#visualising-network-metrics",
    "title": "Hands-on_Ex05",
    "section": "6.2 Visualising network metrics",
    "text": "6.2 Visualising network metrics\n\ng &lt;- GAStech_graph %&gt;%\n  ggraph(layout = \"fr\") + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(colour = Department, \n                      size = centrality_betweenness()))\ng + theme_graph()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#visualising-community",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#visualising-community",
    "title": "Hands-on_Ex05",
    "section": "Visualising Community",
    "text": "Visualising Community\n\ng &lt;- GAStech_graph %&gt;%\n  mutate(community = as.factor(\n    group_edge_betweenness(\n      weights = Weight, \n      directed = TRUE))) %&gt;%\n  ggraph(layout = \"fr\") + \n  geom_edge_link(\n    aes(\n      width=Weight), \n    alpha=0.2) +\n  scale_edge_width(\n    range = c(0.1, 5)) +\n  geom_node_point(\n    aes(colour = community))  \n\ng + theme_graph()\n\n\n\n\n\n\n\n\n\ng &lt;- GAStech_graph %&gt;%\n  activate(nodes) %&gt;%\n  mutate(community = as.factor(\n    group_optimal(weights = Weight)),\n         betweenness_measure = centrality_betweenness()) %&gt;%\n  ggraph(layout = \"fr\") +\n  geom_mark_hull(\n    aes(x, y, \n        group = community, \n        fill = community),  \n    alpha = 0.2,  \n    expand = unit(0.3, \"cm\"),  # Expand\n    radius = unit(0.3, \"cm\")  # Smoothness\n  ) + \n  geom_edge_link(aes(width=Weight), \n                 alpha=0.2) +\n  scale_edge_width(range = c(0.1, 5)) +\n  geom_node_point(aes(fill = Department,\n                      size = betweenness_measure),\n                      color = \"black\",\n                      shape = 21)\n  \ng + theme_graph()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#data-preparation",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#data-preparation",
    "title": "Hands-on_Ex05",
    "section": "7.1 Data Preparation",
    "text": "7.1 Data Preparation\n\nGAStech_edges_aggregated &lt;- GAStech_edges %&gt;%\n  left_join(GAStech_nodes, by = c(\"sourceLabel\" = \"label\")) %&gt;%\n  rename(from = id) %&gt;%\n  left_join(GAStech_nodes, by = c(\"targetLabel\" = \"label\")) %&gt;%\n  rename(to = id) %&gt;%\n  filter(MainSubject == \"Work related\") %&gt;%\n  group_by(from, to) %&gt;%\n    summarise(weight = n()) %&gt;%\n  filter(from!=to) %&gt;%\n  filter(weight &gt; 1) %&gt;%\n  ungroup()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#plotting-the-first-interactive-network-graph",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#plotting-the-first-interactive-network-graph",
    "title": "Hands-on_Ex05",
    "section": "7.2 Plotting the first interactive network graph",
    "text": "7.2 Plotting the first interactive network graph\n\nvisNetwork(GAStech_nodes, \n           GAStech_edges_aggregated)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-layout",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-layout",
    "title": "Hands-on_Ex05",
    "section": "7.3 Working with layout",
    "text": "7.3 Working with layout\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-visual-attributes---nodes",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-visual-attributes---nodes",
    "title": "Hands-on_Ex05",
    "section": "7.4 Working with visual attributes - Nodes",
    "text": "7.4 Working with visual attributes - Nodes\n\nGAStech_nodes &lt;- GAStech_nodes %&gt;%\n  rename(group = Department)\n\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") %&gt;%\n  visLegend() %&gt;%\n  visLayout(randomSeed = 123)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-visual-attributes---edges",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#working-with-visual-attributes---edges",
    "title": "Hands-on_Ex05",
    "section": "7.5 Working with visual attributes - Edges",
    "text": "7.5 Working with visual attributes - Edges\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") %&gt;%\n  visEdges(arrows = \"to\", \n           smooth = list(enabled = TRUE, \n                         type = \"curvedCW\")) %&gt;%\n  visLegend() %&gt;%\n  visLayout(randomSeed = 123)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#interactivity",
    "href": "Hands-on_Ex/Hands-on_Ex05/Hands-on_Ex05.html#interactivity",
    "title": "Hands-on_Ex05",
    "section": "7.6 Interactivity",
    "text": "7.6 Interactivity\n\nvisNetwork(GAStech_nodes,\n           GAStech_edges_aggregated) %&gt;%\n  visIgraphLayout(layout = \"layout_with_fr\") %&gt;%\n  visOptions(highlightNearest = TRUE,\n             nodesIdSelection = TRUE) %&gt;%\n  visLegend() %&gt;%\n  visLayout(randomSeed = 123)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#loading-the-r-packages",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#loading-the-r-packages",
    "title": "Hands-on_Ex03_2",
    "section": "1. Loading the R packages",
    "text": "1. Loading the R packages\n\nplotly: R library for plotting interactive statistical graphs.\ngganimate: An ggplot extension for creating animated statistical graphs.\ngifski: To convert video frames to GIF animations.\ngapminder: An excerpt of the data available at Gapminder.org. We just want to use its country_colors scheme.\ntidyverse: A family of modern R packages specially designed to support data science, analysis and communication task.\nreadxl: An R package used to read .xls and .xlsx into R.\n\n\npacman::p_load(plotly, gganimate, gifski, gapminder, tidyverse, readxl)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#importing-the-data",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#importing-the-data",
    "title": "Hands-on_Ex03_2",
    "section": "2. Importing the data",
    "text": "2. Importing the data\n\ncol &lt;- c(\"Country\", \"Continent\")\n# to create a character vector containing the values \"Country\", \"Continent\"\n\nglobalPop &lt;- read_xls(\"GlobalPopulation.xls\", sheet=\"Data\") %&gt;%\n# %&gt;% is the pipe operator in R, it passes the result of one function into the next\n  \n  mutate(across(all_of(col), as.factor)) %&gt;%\n  # mutate(): to add or change columns in a data frame\n  # across(col, as.factor): to convert the col to factor type\n  # mutate_at() also can be used here\n  \n  mutate(Year = as.integer(Year))\n  # convert year to integer"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#building-a-static-poplulation-bubble-plot",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#building-a-static-poplulation-bubble-plot",
    "title": "Hands-on_Ex03_2",
    "section": "1. Building a static poplulation bubble plot",
    "text": "1. Building a static poplulation bubble plot\n\nggplot(globalPop, aes(x = Old, y = Young, size = Population, colour = Country)) +\n  geom_point(alpha = 0.7, show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  labs(title = 'Year: {frame_time}', x = '% Aged', y = '% Young')"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#building-the-animated-bubble-plot",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#building-the-animated-bubble-plot",
    "title": "Hands-on_Ex03_2",
    "section": "2. Building the animated bubble plot",
    "text": "2. Building the animated bubble plot\n\ntransition_time() is used to create transition through distinct states in time (i.e. Year)\nease_aes() is used to control easing of aesthetics. The default is linear. Other methods are as the following:\n\nquadratic\ncubic\nquartic\nquintic\nsine\ncircular\nexponential\nelastic\nback\nbounce\n\nview_*(): to control the panel behavior\nshadow_*(): to keep traces of previous or future frames\nenter_*()/exit_*() : to define how elements appear and disappear\n\n\nggplot(globalPop, aes(x = Old, y = Young, size = Population, colour = Country)) +\n  geom_point(alpha = 0.7, show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  labs(title = 'Year: {frame_time}', x = '% Aged', y = '% Young') +\n  \n  transition_time(Year) +       \n  ease_aes('linear') + \n  view_follow(fixed_y = TRUE) + \n  # follow the data horizontally\n  shadow_mark(past = TRUE, future = FALSE, alpha = 0.2) +\n  # keep traces of previous frames\n  enter_fade() + exit_shrink()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#building-an-animated-bubble-plot-ggploy",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#building-an-animated-bubble-plot-ggploy",
    "title": "Hands-on_Ex03_2",
    "section": "1. Building an animated bubble plot: ggploy()",
    "text": "1. Building an animated bubble plot: ggploy()\n“show.legend = FALSE” doesn’t work here, so here needs to use “theme(legend.position=‘none’)”\n\ngg &lt;- ggplot(globalPop, aes(x = Old, y = Young, size = Population,\n                            colour = Country)) +\n  geom_point(aes(size = Population, frame = Year), alpha = 0.7,\n             show.legend = FALSE) +\n  scale_colour_manual(values = country_colors) +\n  scale_size(range = c(2, 12)) +\n  labs(x = '% Aged', y = '% Young') + \n  theme(legend.position='none')\n\nggplotly(gg)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#building-an-animated-bubble-plot-plot_ly",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_2.html#building-an-animated-bubble-plot-plot_ly",
    "title": "Hands-on_Ex03_2",
    "section": "2. Building an animated bubble plot: plot_ly()",
    "text": "2. Building an animated bubble plot: plot_ly()\n\nbp &lt;- globalPop %&gt;%\n  \n  plot_ly(x = ~Old, y = ~Young, size = ~Population, color = ~Continent,\n          sizes = c(2, 100), frame = ~Year, text = ~Country, hoverinfo = \"text\",\n          type = 'scatter', mode = 'markers') %&gt;%\n  \n  layout(showlegend = FALSE)\n\nbp"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html",
    "title": "Hands-on_Ex04_1",
    "section": "",
    "text": "ggridges, a ggplot2 extension specially designed for plotting ridgeline plots\nggdist, a ggplot2 extension specially desgin for visualising distribution and uncertainty\ncolorspace, an R package provides a broad toolbox for selecting individual colors or color palettes, manipulating these colors, and employing them in various kinds of visualisations.\n\n\npacman::p_load(ggdist, ggridges, ggthemes, colorspace, tidyverse)\n\n\n\n\n\nexam &lt;- read_csv(\"Exam_data.csv\")\n\n\n\n\n\n\n\nggridges package provides two main geom to plot gridgeline plots:\n\ngeom_ridgeline(): takes height values directly to draw the ridgelines.\ngeom_density_ridges(): estimates data densities first and then draws those using ridgelines.\n\n\nggplot(exam, aes(x = ENGLISH, y = CLASS)) +\n  geom_density_ridges(scale = 3, rel_min_height = 0.01,\n                      bandwidth = 3.4,\n                      fill = lighten(\"#7097BB\", .3),\n                      color = \"white\") +\n  scale_x_continuous(name = \"English grades\",expand = c(0, 0)) +\n  scale_y_discrete(name = NULL, \n                   expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()\n\n\n\n\n\n\n\n\n\n\n\ngeom_ridgeline_gradient() or geom_density_ridges_gradient() can be used to vary fill color along the x axis. However, they do not allow for alpha transparency in the fill. For technical reasons, we can have changing fill colors or transparency but not both.\n\nggplot(exam, aes(x = ENGLISH, y = CLASS, fill = stat(x))) +\n  geom_density_ridges_gradient(scale = 3,\n                               rel_min_height = 0.01) +\n  scale_fill_viridis_c(name = \"Temp. [F]\", option = \"C\") +\n  scale_x_continuous(name = \"English grades\",\n                     expand = c(0, 0)) +\n  scale_y_discrete(name = NULL, \n                   expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, aes(x = ENGLISH, y = CLASS,\n                 fill = 0.5 - abs(0.5-stat(ecdf)))) +\n  stat_density_ridges(geom = \"density_ridges_gradient\",\n                      calc_ecdf = TRUE) +\n  scale_fill_viridis_c(name = \"Tail probability\", \n                       direction = -1) +\n  theme_ridges()\n\n\n\n\n\n\n\n\n\n\n\nBy using geom_density_ridges_gradient(), we can colour the ridgeline plot by quantile.\n\nggplot(exam, aes(x = ENGLISH, y = CLASS,\n                 fill = factor(stat(quantile)))) +\n  stat_density_ridges(geom = \"density_ridges_gradient\",\n                      calc_ecdf = TRUE, quantiles = 4,\n                      quantile_lines = TRUE) +\n  scale_fill_viridis_d(name = \"Quartiles\") +\n  theme_ridges()\n\n\n\n\n\n\n\n\nwe can also specify quantiles by cut points such as 10% and 90% tails to colour the ridgeline plot as shown in the figure below.\n\nggplot(exam, aes(x = ENGLISH, y = CLASS, \n                 fill = factor(stat(quantile)))) +\n  stat_density_ridges(geom = \"density_ridges_gradient\",\n                      calc_ecdf = TRUE, \n                      quantiles = c(0.100, 0.900)) +\n  scale_fill_manual(name = \"Probability\", values = c(\"#FF0000A0\", \"#A0A0A0A0\", \"#0000FFA0\"), labels = c(\"(0, 0.100]\", \"(0.100, 0.900]\", \"(0.900, 1]\")) +\n  theme_ridges()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, aes(x = RACE, y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5, justification = -0.2,\n               .width = 0, point_colour = NA)\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, aes(x = RACE, y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5, justification = -0.2,\n               .width = 0, point_colour = NA) +\n  geom_boxplot(width = .20, outlier.shape = NA)\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, aes(x = RACE, y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5, justification = -0.2,\n               .width = 0, point_colour = NA) +\n  geom_boxplot(width = .20, outlier.shape = NA) +\n  stat_dots(side = \"left\", justification = 1.2, \n            binwidth = .5, dotsize = 2)\n\n\n\n\n\n\n\n\n\n\n\ncoord_flip() of ggplot2 package can be used to flip the raincloud chart horizontally. Besides, themes in the ggthemes package can be used to give the raincloud chart a professional publishing standard look.\n\nggplot(exam, aes(x = RACE, y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5, justification = -0.2,\n               .width = 0, point_colour = NA) +\n  geom_boxplot(width = .20, outlier.shape = NA) +\n  stat_dots(side = \"left\", justification = 1.2, \n            binwidth = .5, dotsize = 1.5) +\n  coord_flip() + theme_wsj()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#getting-started",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#getting-started",
    "title": "Hands-on_Ex04_1",
    "section": "",
    "text": "ggridges, a ggplot2 extension specially designed for plotting ridgeline plots\nggdist, a ggplot2 extension specially desgin for visualising distribution and uncertainty\ncolorspace, an R package provides a broad toolbox for selecting individual colors or color palettes, manipulating these colors, and employing them in various kinds of visualisations.\n\n\npacman::p_load(ggdist, ggridges, ggthemes, colorspace, tidyverse)\n\n\n\n\n\nexam &lt;- read_csv(\"Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#visualizing-distribution-with-ridgeline-plot",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#visualizing-distribution-with-ridgeline-plot",
    "title": "Hands-on_Ex04_1",
    "section": "",
    "text": "ggridges package provides two main geom to plot gridgeline plots:\n\ngeom_ridgeline(): takes height values directly to draw the ridgelines.\ngeom_density_ridges(): estimates data densities first and then draws those using ridgelines.\n\n\nggplot(exam, aes(x = ENGLISH, y = CLASS)) +\n  geom_density_ridges(scale = 3, rel_min_height = 0.01,\n                      bandwidth = 3.4,\n                      fill = lighten(\"#7097BB\", .3),\n                      color = \"white\") +\n  scale_x_continuous(name = \"English grades\",expand = c(0, 0)) +\n  scale_y_discrete(name = NULL, \n                   expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()\n\n\n\n\n\n\n\n\n\n\n\ngeom_ridgeline_gradient() or geom_density_ridges_gradient() can be used to vary fill color along the x axis. However, they do not allow for alpha transparency in the fill. For technical reasons, we can have changing fill colors or transparency but not both.\n\nggplot(exam, aes(x = ENGLISH, y = CLASS, fill = stat(x))) +\n  geom_density_ridges_gradient(scale = 3,\n                               rel_min_height = 0.01) +\n  scale_fill_viridis_c(name = \"Temp. [F]\", option = \"C\") +\n  scale_x_continuous(name = \"English grades\",\n                     expand = c(0, 0)) +\n  scale_y_discrete(name = NULL, \n                   expand = expansion(add = c(0.2, 2.6))) +\n  theme_ridges()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#mapping-the-probabilities-directly-onto-colour-stat_density_ridges",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#mapping-the-probabilities-directly-onto-colour-stat_density_ridges",
    "title": "Hands-on_Ex04_1",
    "section": "",
    "text": "ggplot(exam, aes(x = ENGLISH, y = CLASS,\n                 fill = 0.5 - abs(0.5-stat(ecdf)))) +\n  stat_density_ridges(geom = \"density_ridges_gradient\",\n                      calc_ecdf = TRUE) +\n  scale_fill_viridis_c(name = \"Tail probability\", \n                       direction = -1) +\n  theme_ridges()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#ridgeline-plots-with-quantile-lines",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#ridgeline-plots-with-quantile-lines",
    "title": "Hands-on_Ex04_1",
    "section": "",
    "text": "By using geom_density_ridges_gradient(), we can colour the ridgeline plot by quantile.\n\nggplot(exam, aes(x = ENGLISH, y = CLASS,\n                 fill = factor(stat(quantile)))) +\n  stat_density_ridges(geom = \"density_ridges_gradient\",\n                      calc_ecdf = TRUE, quantiles = 4,\n                      quantile_lines = TRUE) +\n  scale_fill_viridis_d(name = \"Quartiles\") +\n  theme_ridges()\n\n\n\n\n\n\n\n\nwe can also specify quantiles by cut points such as 10% and 90% tails to colour the ridgeline plot as shown in the figure below.\n\nggplot(exam, aes(x = ENGLISH, y = CLASS, \n                 fill = factor(stat(quantile)))) +\n  stat_density_ridges(geom = \"density_ridges_gradient\",\n                      calc_ecdf = TRUE, \n                      quantiles = c(0.100, 0.900)) +\n  scale_fill_manual(name = \"Probability\", values = c(\"#FF0000A0\", \"#A0A0A0A0\", \"#0000FFA0\"), labels = c(\"(0, 0.100]\", \"(0.100, 0.900]\", \"(0.900, 1]\")) +\n  theme_ridges()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#visualising-distribution-with-raincloud-plot",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_1.html#visualising-distribution-with-raincloud-plot",
    "title": "Hands-on_Ex04_1",
    "section": "",
    "text": "ggplot(exam, aes(x = RACE, y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5, justification = -0.2,\n               .width = 0, point_colour = NA)\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, aes(x = RACE, y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5, justification = -0.2,\n               .width = 0, point_colour = NA) +\n  geom_boxplot(width = .20, outlier.shape = NA)\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(exam, aes(x = RACE, y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5, justification = -0.2,\n               .width = 0, point_colour = NA) +\n  geom_boxplot(width = .20, outlier.shape = NA) +\n  stat_dots(side = \"left\", justification = 1.2, \n            binwidth = .5, dotsize = 2)\n\n\n\n\n\n\n\n\n\n\n\ncoord_flip() of ggplot2 package can be used to flip the raincloud chart horizontally. Besides, themes in the ggthemes package can be used to give the raincloud chart a professional publishing standard look.\n\nggplot(exam, aes(x = RACE, y = ENGLISH)) +\n  stat_halfeye(adjust = 0.5, justification = -0.2,\n               .width = 0, point_colour = NA) +\n  geom_boxplot(width = .20, outlier.shape = NA) +\n  stat_dots(side = \"left\", justification = 1.2, \n            binwidth = .5, dotsize = 1.5) +\n  coord_flip() + theme_wsj()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#installing-and-loading-the-packages",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#installing-and-loading-the-packages",
    "title": "Hand-on_Ex04_3",
    "section": "1.1 Installing and loading the packages",
    "text": "1.1 Installing and loading the packages\n\ncrosstalk: to implement cross-widget interactions (currently, linked brushing and filtering)\nggdist: to visualize distribution and uncertainty\n\n\npacman::p_load(plotly, crosstalk, DT, ggdist, ggridges, colorspace, \n               gganimate, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#data-import",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#data-import",
    "title": "Hand-on_Ex04_3",
    "section": "1.2 Data Import",
    "text": "1.2 Data Import\n\nexam &lt;- read_csv(\"Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#dataframe-my_sum",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#dataframe-my_sum",
    "title": "Hand-on_Ex04_3",
    "section": "2.1 Dataframe my_sum",
    "text": "2.1 Dataframe my_sum\n\nmy_sum &lt;- exam %&gt;%\n  group_by(RACE) %&gt;%\n  summarise(n=n(), mean=mean(MATHS), sd=sd(MATHS)) %&gt;%\n  mutate(se=sd/sqrt(n-1))\n\nknitr::kable(head(my_sum), format = 'html')\n\n\n\n\nRACE\nn\nmean\nsd\nse\n\n\n\n\nChinese\n193\n76.50777\n15.69040\n1.132357\n\n\nIndian\n12\n60.66667\n23.35237\n7.041005\n\n\nMalay\n108\n57.44444\n21.13478\n2.043177\n\n\nOthers\n9\n69.66667\n10.72381\n3.791438"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#plotting-standard-error-bars-of-point-estimates",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#plotting-standard-error-bars-of-point-estimates",
    "title": "Hand-on_Ex04_3",
    "section": "2.2 Plotting standard error bars of point estimates",
    "text": "2.2 Plotting standard error bars of point estimates\n\nggplot(my_sum) +\n  geom_errorbar(aes(x=RACE, ymin=mean-se, ymax=mean+se),\n                width=0.2, colour=\"black\", alpha=0.9, linewidth=0.5) +\n  geom_point(aes(x=RACE, y=mean), stat=\"identity\", \n             color=\"red\", size = 1.5, alpha=1) +\n  ggtitle(\"Standard error of mean maths score by rac\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#plotting-confidence-interval-of-point-estimates",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#plotting-confidence-interval-of-point-estimates",
    "title": "Hand-on_Ex04_3",
    "section": "2.3 Plotting confidence interval of point estimates",
    "text": "2.3 Plotting confidence interval of point estimates\n\nggplot(my_sum) +\n  geom_errorbar(aes(x=reorder(RACE, -mean), ymin=mean-1.96*se, ymax=mean+1.96*se),\n                width=0.2, colour=\"black\", alpha=0.9, linewidth=0.5) +\n  geom_point(aes(x=RACE, y=mean), stat=\"identity\", color=\"red\", \n             size = 1.5, alpha=1) +\n  labs(x = \"Maths score\", title = \"95% confidence interval of mean maths score by race\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#visualizing-the-uncertainty-of-point-estimates-with-interactive-error-bars",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#visualizing-the-uncertainty-of-point-estimates-with-interactive-error-bars",
    "title": "Hand-on_Ex04_3",
    "section": "2.4 Visualizing the uncertainty of point estimates with interactive error bars",
    "text": "2.4 Visualizing the uncertainty of point estimates with interactive error bars\n\nshared_df = SharedData$new(my_sum)\n\nbscols(widths = c(4,8),\n       ggplotly((ggplot(shared_df) +\n                   geom_errorbar(aes(\n                     x=reorder(RACE, -mean),\n                     ymin=mean-2.58*se, \n                     ymax=mean+2.58*se), \n                     width=0.2, \n                     colour=\"black\", \n                     alpha=0.9, \n                     size=0.5) +\n                   geom_point(aes(\n                     x=RACE, \n                     y=mean, \n                     text = paste(\"Race:\", `RACE`, \n                                  \"&lt;br&gt;N:\", `n`,\n                                  \"&lt;br&gt;Avg. Scores:\", round(mean, digits = 2),\n                                  \"&lt;br&gt;95% CI:[\", \n                                  round((mean-2.58*se), digits = 2), \",\",\n                                  round((mean+2.58*se), digits = 2),\"]\")),\n                     stat=\"identity\", \n                     color=\"red\", \n                     size = 1.5, \n                     alpha=1) + \n                   xlab(\"Race\") + \n                   ylab(\"Average Scores\") + \n                   theme_minimal() + \n                   theme(axis.text.x = element_text(\n                     angle = 45, vjust = 0.5, hjust=1),\n                     plot.title = element_text(size = 7)) +\n                   ggtitle(\"99% Confidence interval of average /&lt;br&gt;maths scores by race\")), \n                tooltip = \"text\"), \n       DT::datatable(shared_df, \n                     rownames = FALSE, \n                     class=\"compact\", \n                     width=\"100%\", \n                     options = list(pageLength = 10,\n                                    scrollX=T), \n                     colnames = c(\"No. of pupils\", \n                                  \"Avg Scores\",\n                                  \"Std Dev\",\n                                  \"Std Error\")) %&gt;%\n         formatRound(columns=c('mean', 'sd', 'se'),\n                     digits=2))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#stat_pointinterval",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#stat_pointinterval",
    "title": "Hand-on_Ex04_3",
    "section": "3.1 stat_pointinterval()",
    "text": "3.1 stat_pointinterval()\nstat_pointinterval() of ggdist is used to build a visual for displaying distribution of maths scores by race.\n\nexam %&gt;%\n  ggplot(aes(x = RACE, y = MATHS)) +\n  stat_pointinterval(.width = 0.95,\n  .point = median,\n  .interval = qi) +\n  labs(\n    title = \"Visualising confidence intervals of median math score\",\n    subtitle = \"Median Point + Multiple-interval plot\")\n\n\n\n\n\n\n\n\n\nexam %&gt;%\n  ggplot(aes(x = RACE, y = MATHS)) +\n  stat_pointinterval(.width = c(0.95,0.99),\n  .point = mean,\n  .interval = qi,\n  show.legend = FALSE) +\n  labs(\n    title = \"Visualising confidence intervals of median math score\",\n    subtitle = \"Mean Point + Multiple-interval plot\")\n\n\n\n\n\n\n\n\n\nexam %&gt;%\n  ggplot(aes(x = RACE, \n             y = MATHS)) +\n  stat_pointinterval(\n    show.legend = FALSE) +   \n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Mean Point + Multiple-interval plot\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#stat_gradientinterval",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#stat_gradientinterval",
    "title": "Hand-on_Ex04_3",
    "section": "3.2 stat_gradientinterval()",
    "text": "3.2 stat_gradientinterval()\nstat_gradientinterval() of ggdist is used to build a visual for displaying distribution of maths scores by race.\n\nexam %&gt;%\n  ggplot(aes(x = RACE, \n             y = MATHS)) +\n  stat_gradientinterval(   \n    fill = \"skyblue\",      \n    show.legend = TRUE     \n  ) +                        \n  labs(\n    title = \"Visualising confidence intervals of mean math score\",\n    subtitle = \"Gradient + interval plot\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#installing-ungeviz-package",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#installing-ungeviz-package",
    "title": "Hand-on_Ex04_3",
    "section": "4.1 Installing ungeviz package",
    "text": "4.1 Installing ungeviz package\n\ndevtools::install_github(\"wilkelab/ungeviz\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#launch-the-application-in-r",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#launch-the-application-in-r",
    "title": "Hand-on_Ex04_3",
    "section": "4.2 Launch the application in R",
    "text": "4.2 Launch the application in R\n\nlibrary(ungeviz)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#visualising-uncertainty-with-hypothetical-outcome-plots-hops-1",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_3.html#visualising-uncertainty-with-hypothetical-outcome-plots-hops-1",
    "title": "Hand-on_Ex04_3",
    "section": "4.3 Visualising Uncertainty with Hypothetical Outcome Plots (HOPs)",
    "text": "4.3 Visualising Uncertainty with Hypothetical Outcome Plots (HOPs)\n\nggplot(data = exam, \n       (aes(x = factor(RACE), \n            y = MATHS))) +\n  geom_point(position = position_jitter(\n    height = 0.3, \n    width = 0.05), \n    size = 0.4, \n    color = \"#0072B2\", \n    alpha = 1/2) +\n  geom_hpline(data = sampler(25, \n                             group = RACE), \n              height = 0.6, \n              color = \"#D55E00\") +\n  theme_bw() + \n  transition_states(.draw, 1, 3)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#the-basic-plot",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#the-basic-plot",
    "title": "Hands-on_Ex04_4",
    "section": "3.1 The basic plot",
    "text": "3.1 The basic plot\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Positive,\n  denominator = Death,\n  group = `Sub-district`\n)\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 0 are outliers. \nPlot is adjusted for overdispersion."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#makeover-1",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#makeover-1",
    "title": "Hands-on_Ex04_4",
    "section": "3.2 Makeover 1",
    "text": "3.2 Makeover 1\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Death,\n  denominator = Positive,\n  group = `Sub-district`,\n  data_type = \"PR\",     #&lt;&lt;\n  xrange = c(0, 6500),  #&lt;&lt;\n  yrange = c(0, 0.05)   #&lt;&lt;\n)\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#makeover-2",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#makeover-2",
    "title": "Hands-on_Ex04_4",
    "section": "3.3 Makeover 2",
    "text": "3.3 Makeover 2\n\nfunnel_plot(\n  .data = covid19,\n  numerator = Death,\n  denominator = Positive,\n  group = `Sub-district`,\n  data_type = \"PR\",   \n  xrange = c(0, 6500),  \n  yrange = c(0, 0.05),\n  label = NA,\n  title = \"Cumulative COVID-19 Fatality Rate by Cumulative Total Number of COVID-19 Positive Cases\", #&lt;&lt;           \n  x_label = \"Cumulative COVID-19 Positive Cases\", #&lt;&lt;\n  y_label = \"Cumulative Fatality Rate\"  #&lt;&lt;\n)\n\n\n\n\n\n\n\n\nA funnel plot object with 267 points of which 7 are outliers. \nPlot is adjusted for overdispersion."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#computing-the-basic-derived-fields",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#computing-the-basic-derived-fields",
    "title": "Hands-on_Ex04_4",
    "section": "4.1 Computing the basic derived fields",
    "text": "4.1 Computing the basic derived fields\n\ndf &lt;- covid19 %&gt;%\n  mutate(rate = Death / Positive) %&gt;%\n  mutate(rate.se = sqrt((rate*(1-rate)) / (Positive))) %&gt;%\n  filter(rate &gt; 0)\n\nfit.mean &lt;- weighted.mean(df$rate, 1/df$rate.se^2)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#calculate-lower-and-upper-limits-for-95-and-99.9-ci",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#calculate-lower-and-upper-limits-for-95-and-99.9-ci",
    "title": "Hands-on_Ex04_4",
    "section": "4.2 Calculate lower and upper limits for 95% and 99.9% CI",
    "text": "4.2 Calculate lower and upper limits for 95% and 99.9% CI\n\nnumber.seq &lt;- seq(1, max(df$Positive), 1)\nnumber.ll95 &lt;- fit.mean - 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul95 &lt;- fit.mean + 1.96 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ll999 &lt;- fit.mean - 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \nnumber.ul999 &lt;- fit.mean + 3.29 * sqrt((fit.mean*(1-fit.mean)) / (number.seq)) \ndfCI &lt;- data.frame(number.ll95, number.ul95, number.ll999, \n                   number.ul999, number.seq, fit.mean)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#plotting-a-static-funnel-plot",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#plotting-a-static-funnel-plot",
    "title": "Hands-on_Ex04_4",
    "section": "4.3 Plotting a static funnel plot",
    "text": "4.3 Plotting a static funnel plot\n\np &lt;- ggplot(df, aes(x = Positive, y = rate)) +\n  geom_point(aes(label=`Sub-district`), \n             alpha=0.4) +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll95), \n            size = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul95), \n            size = 0.4, \n            colour = \"grey40\", \n            linetype = \"dashed\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ll999), \n            size = 0.4, \n            colour = \"grey40\") +\n  geom_line(data = dfCI, \n            aes(x = number.seq, \n                y = number.ul999), \n            size = 0.4, \n            colour = \"grey40\") +\n  geom_hline(data = dfCI, \n             aes(yintercept = fit.mean), \n             size = 0.4, \n             colour = \"grey40\") +\n  coord_cartesian(ylim=c(0,0.05)) +\n  annotate(\"text\", x = 1, y = -0.13, label = \"95%\", size = 3, colour = \"grey40\") + \n  annotate(\"text\", x = 4.5, y = -0.18, label = \"99%\", size = 3, colour = \"grey40\") + \n  ggtitle(\"Cumulative Fatality Rate by Cumulative Number of COVID-19 Cases\") +\n  xlab(\"Cumulative Number of COVID-19 Cases\") + \n  ylab(\"Cumulative Fatality Rate\") +\n  theme_light() +\n  theme(plot.title = element_text(size=12),\n        legend.position = c(0.91,0.85), \n        legend.title = element_text(size=7),\n        legend.text = element_text(size=7),\n        legend.background = element_rect(colour = \"grey60\", linetype = \"dotted\"),\n        legend.key.height = unit(0.3, \"cm\"))\np"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#interactive-funnel-plot-plotly-ggplot2",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_4.html#interactive-funnel-plot-plotly-ggplot2",
    "title": "Hands-on_Ex04_4",
    "section": "4.4 Interactive Funnel Plot: plotly + ggplot2",
    "text": "4.4 Interactive Funnel Plot: plotly + ggplot2\n\nfp_ggplotly &lt;- ggplotly(p,\n  tooltip = c(\"label\", \n              \"x\", \n              \"y\"))\nfp_ggplotly"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html",
    "title": "Hands-on_Ex04_2",
    "section": "",
    "text": "ggstatsplot is an extension of ggplot2 package for creating graphics with details from statistical tests included in the information-rich plots themselves.\n\npacman::p_load(ggstatsplot, tidyverse)\n\n\n\n\n\nexam &lt;- read_csv(\"Exam_data.csv\")\n\n\n\n\n\nset.seed(1234)\n\ngghistostats(data = exam, x = ENGLISH, type = \"bayes\",\n             test.value = 60, xlab = \"English scores\")\n\n\n\n\n\n\n\n\n\n\n\n\nggbetweenstats(data = exam, x = GENDER, y = MATHS,\n               type = \"np\", messages = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\nggbetweenstats(data = exam, x = RACE, y = ENGLISH,\n               type = \"p\", mean.ci = TRUE,\n               pairwise.comparisons = TRUE,\n               pairwise.display = \"s\",\n               p.adjust.method = \"fdr\",\n               messages = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\nggscatterstats(data = exam, x = MATHS, y = ENGLISH,\n               marginal = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\nexam1 &lt;- exam %&gt;% \n  mutate(MATHS_bins =\n           cut(MATHS, breaks = c(0,60,75,85,100)))\n\n\nggbarstats(exam1, x = MATHS_bins, y = GENDER)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#installing-and-loading-packages",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#installing-and-loading-packages",
    "title": "Hands-on_Ex04_2",
    "section": "",
    "text": "ggstatsplot is an extension of ggplot2 package for creating graphics with details from statistical tests included in the information-rich plots themselves.\n\npacman::p_load(ggstatsplot, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#importing-data",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#importing-data",
    "title": "Hands-on_Ex04_2",
    "section": "",
    "text": "exam &lt;- read_csv(\"Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#one-sample-test-gghistostats-method",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#one-sample-test-gghistostats-method",
    "title": "Hands-on_Ex04_2",
    "section": "",
    "text": "set.seed(1234)\n\ngghistostats(data = exam, x = ENGLISH, type = \"bayes\",\n             test.value = 60, xlab = \"English scores\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#two-sample-mean-test-ggbetweenstats",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#two-sample-mean-test-ggbetweenstats",
    "title": "Hands-on_Ex04_2",
    "section": "",
    "text": "ggbetweenstats(data = exam, x = GENDER, y = MATHS,\n               type = \"np\", messages = FALSE)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#oneway-anova-test-ggbetweenstats-method",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#oneway-anova-test-ggbetweenstats-method",
    "title": "Hands-on_Ex04_2",
    "section": "",
    "text": "ggbetweenstats(data = exam, x = RACE, y = ENGLISH,\n               type = \"p\", mean.ci = TRUE,\n               pairwise.comparisons = TRUE,\n               pairwise.display = \"s\",\n               p.adjust.method = \"fdr\",\n               messages = FALSE)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#significant-test-of-correlation-ggscatterstats",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#significant-test-of-correlation-ggscatterstats",
    "title": "Hands-on_Ex04_2",
    "section": "",
    "text": "ggscatterstats(data = exam, x = MATHS, y = ENGLISH,\n               marginal = FALSE)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#significant-test-of-association-depedence-ggbarstats-methods",
    "href": "Hands-on_Ex/Hands-on_Ex04/Hands-on_Ex04_2.html#significant-test-of-association-depedence-ggbarstats-methods",
    "title": "Hands-on_Ex04_2",
    "section": "",
    "text": "exam1 &lt;- exam %&gt;% \n  mutate(MATHS_bins =\n           cut(MATHS, breaks = c(0,60,75,85,100)))\n\n\nggbarstats(exam1, x = MATHS_bins, y = GENDER)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#loading-packages",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#loading-packages",
    "title": "Hands-on Exercise 3-1",
    "section": "1. Loading packages",
    "text": "1. Loading packages\nPackages Introduction\n\nggiraph: to make ggplot graphics interactive\nplotly: to plot interactive statistical graphs\nDT: to provide an R interface to the JavaScript library DataTables to create interactive table on html page\ntidyverse: a family of modern R packages specially designed to support data science, analysis and communication task\npatchwork: to combine multiple ggplot2 graphs into one figure\n\n\npacman::p_load(ggiraph, plotly, patchwork, DT, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#importing-data",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#importing-data",
    "title": "Hands-on Exercise 3-1",
    "section": "2. Importing data",
    "text": "2. Importing data\n\nexam_data&lt;-read_csv(\"Exam_data.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#tooltip",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#tooltip",
    "title": "Hands-on Exercise 3-1",
    "section": "1. tooltip",
    "text": "1. tooltip\nTooltip’s function is to display the information when the mouse is over elements.\n\n(1) Displaying one information on tooltip\n\np &lt;- ggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(tooltip = ID), stackgroups = TRUE, \n                           binwidth = 1, method = \"histodot\") +\n  scale_y_continuous(NULL, breaks = NULL)\n\ngirafe(ggobj = p, width_svg = 6, height_svg = 6*0.618)\n\n\n\n\n\n\n\n(2) Displaying multiple information on tooltip\n\nexam_data$tooltip &lt;- paste0(\"Name = \", exam_data$ID,\"\\n CLASS = \", exam_data$CLASS)\n# create a new field called tooltip, including ID and CLASS.\n# paste0(): to concatenate strings\n\np &lt;- ggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(tooltip = exam_data$tooltip),\n                           stackgroups = TRUE, binwidth = 1, \n                           method = \"histodot\") +\n  scale_y_continuous(NULL, breaks = NULL)\n\ngirafe(ggobj = p, width_svg = 6, height_svg = 6*0.618)\n\n\n\n\n\n\n\n(3) Customising Tooltip style\n\ntooltip_css &lt;- \"background-color:white; font-style:bold; color:black;\" \n\np &lt;- ggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(tooltip = ID), stackgroups = TRUE, binwidth = 1, method = \"histodot\") +\n  scale_y_continuous(NULL, breaks = NULL)\n\ngirafe(ggobj = p, width_svg = 6, height_svg = 6*0.618,\n  options = list(opts_tooltip(css = tooltip_css))) \n\n\n\n\n\n\n\n(4) Displaying statistics on tooltip\n\ntooltip &lt;- function(y, ymax, accuracy = .01) {\n  mean &lt;- scales::number(y, accuracy = accuracy)\n  sem &lt;- scales::number(ymax - y, accuracy = accuracy)\n  paste(\"Mean maths scores:\", mean, \"+/-\", sem)\n}\n\ngg_point &lt;- ggplot(data=exam_data, \n                   aes(x = RACE)) +\n  stat_summary(aes(y = MATHS, tooltip = after_stat(tooltip(y, ymax))),  \n    fun.data = \"mean_se\", geom = GeomInteractiveCol,fill = \"light pink\") +\n  stat_summary(aes(y = MATHS),fun.data = mean_se,geom = \"errorbar\", width = 0.2, size = 0.2)\n\ngirafe(ggobj = gg_point, width_svg = 8, height_svg = 8*0.618)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#data_id",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#data_id",
    "title": "Hands-on Exercise 3-1",
    "section": "2. Data_id",
    "text": "2. Data_id\nData_id is used to assign a unique identifier to each graphic element. In this case, elements associated with a data_id will be highlighted upon mouse over.\n\np &lt;- ggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(data_id = CLASS), stackgroups = TRUE, binwidth = 1, method = \"histodot\") +\n  scale_y_continuous(NULL, breaks = NULL)\n\ngirafe(ggobj = p, width_svg = 6, height_svg = 6*0.618)\n\n\n\n\n\n\n(1)Styling hover effect\n\np &lt;- ggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(data_id = CLASS), stackgroups = TRUE, binwidth = 1, method = \"histodot\") +               \n  scale_y_continuous(NULL, breaks = NULL)\n\ngirafe(ggobj = p,width_svg = 6,height_svg = 6*0.618,\n  options = list(opts_hover(css = \"fill: #202020;\"), opts_hover_inv(css = \"opacity:0.2;\")))                                        \n\n\n\n\n\n\n\n(2) Combing tooltip and hover effect\n\np &lt;- ggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(tooltip=CLASS,data_id = CLASS), stackgroups = TRUE, binwidth = 1, method = \"histodot\") +               \n  scale_y_continuous(NULL, breaks = NULL)\n\ngirafe(ggobj = p,width_svg = 6,height_svg = 6*0.618,\n  options = list(opts_hover(css = \"fill: #202020;\"), opts_hover_inv(css = \"opacity:0.2;\")))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#onclick",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#onclick",
    "title": "Hands-on Exercise 3-1",
    "section": "3. Onclick",
    "text": "3. Onclick\nOnclick is to define a JavaScript action that happens when the user clicks on a visual element.\n\nexam_data$onclick &lt;- sprintf(\"window.open(\\\"%s%s\\\")\",\n\"https://www.moe.gov.sg/schoolfinder?journey=Primary%20school\",\nas.character(exam_data$ID))\n\np &lt;- ggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(onclick = onclick), stackgroups = TRUE, binwidth = 1, method = \"histodot\") +\n  scale_y_continuous(NULL, breaks = NULL)\n\ngirafe(ggobj = p, width_svg = 6, height_svg = 6*0.618)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#coordinate-multiple-views-with-ggiraph",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#coordinate-multiple-views-with-ggiraph",
    "title": "Hands-on Exercise 3-1",
    "section": "4. Coordinate multiple views with ggiraph",
    "text": "4. Coordinate multiple views with ggiraph\nTo achieve this, appropriate interactive functions of ggiraph will be used to create the multiple views, and patchwork function will be used inside girafe function to coordinate multiple views.\n\np1 &lt;- ggplot(data=exam_data, aes(x = MATHS)) +\n  geom_dotplot_interactive(aes(data_id = ID), stackgroups = TRUE, binwidth = 1, method = \"histodot\") +  \n  coord_cartesian(xlim=c(0,100)) + \n  scale_y_continuous(NULL, breaks = NULL)\n\np2 &lt;- ggplot(data=exam_data, aes(x = ENGLISH)) +\n  geom_dotplot_interactive(aes(data_id = ID), stackgroups = TRUE, binwidth = 1, method = \"histodot\") +  \n  coord_cartesian(xlim=c(0,100)) + \n  scale_y_continuous(NULL, breaks = NULL)\n\ngirafe(code = print(p1 + p2), width_svg = 6, height_svg = 3, \n       options = list(opts_hover(css = \"fill: #202020;\"), \n              opts_hover_inv(css = \"opacity:0.2;\")))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#plot_ly-method",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#plot_ly-method",
    "title": "Hands-on Exercise 3-1",
    "section": "1. plot_ly() method",
    "text": "1. plot_ly() method\n\nplot_ly(data = exam_data, x = ~MATHS, y = ~ENGLISH, color = ~RACE)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#ggplotly-method",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#ggplotly-method",
    "title": "Hands-on Exercise 3-1",
    "section": "2. ggplotly() method",
    "text": "2. ggplotly() method\n\np &lt;- ggplot(data=exam_data, aes(x = MATHS, y = ENGLISH, colour = RACE)) + \n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100), ylim=c(0,100))\n\nggplotly(p)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#coordinate-multiple-views-with-plotly",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#coordinate-multiple-views-with-plotly",
    "title": "Hands-on Exercise 3-1",
    "section": "3. Coordinate multiple views with plotly",
    "text": "3. Coordinate multiple views with plotly\nDifferent from coordinating multiple views with ggiraph by using patchwork, Here are three steps to coordinate multiple views with plotly.\n\nhighlight_key() of plotly is used as shared data\n2 scatterplots will be created by using ggplot2 functions\nsubplot() of plotly is used to place them next to each other side-by-side\n\n\nd &lt;- highlight_key(exam_data)\n\np1 &lt;- ggplot(data=d,aes(x = MATHS, y = ENGLISH, colour = RACE)) +\n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100), ylim=c(0,100))\n\np2 &lt;- ggplot(data=d, aes(x = MATHS, y = SCIENCE, colour = RACE)) +\n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100), ylim=c(0,100))\n\nsubplot(ggplotly(p1), ggplotly(p2))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#dt-package",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#dt-package",
    "title": "Hands-on Exercise 3-1",
    "section": "1. DT package",
    "text": "1. DT package\n\nDT::datatable(exam_data, class= \"compact\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#linked-brushing",
    "href": "Hands-on_Ex/Hands-on_Ex03/Hands-on_Ex03_1.html#linked-brushing",
    "title": "Hands-on Exercise 3-1",
    "section": "2. Linked brushing",
    "text": "2. Linked brushing\n\nLinked brushing is an interactive feature where selecting data points in one widget highlights the same points in another widget.\nhighlight() is a function of plotly package, to set a variety of options for brushing (i.e., highlighting) multiple plots.\nbscols() is a function of crosstalk package, to make it easy to put HTML elements side by side.\n\n\nd &lt;- highlight_key(exam_data) \n\np &lt;- ggplot(d, aes(ENGLISH, MATHS)) + \n  geom_point(size=1) +\n  coord_cartesian(xlim=c(0,100), ylim=c(0,100))\n\ngg &lt;- highlight(ggplotly(p), \"plotly_selected\")  \n\ncrosstalk::bscols(gg, DT::datatable(d), widths = 5)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html",
    "title": "Hands-on_Ex02",
    "section": "",
    "text": "pacman::p_load(ggrepel,\n               ggthemes,\n               hrbrthemes,\n               patchwork,\n               tidyverse)\n\n\n\n\n\nexam_data&lt;-read_csv(\"Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data,\n       aes(x=MATHS,\n           y=ENGLISH))+\n  geom_point()+\n  geom_smooth(method = lm,\n              linewidth=0.5)+\n  geom_label(aes(label=ID),\n             hjust=.5,\n             vjust=-.5)+\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100))+\n  ggtitle(\"English scores versus Maths scores for primary 3\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data,\n       aes(x=MATHS,\n           y=ENGLISH))+\n  geom_point()+\n  geom_smooth(method = lm,\n              linewidth=0.5)+\n  geom_label_repel(aes(label = ID),\n                   fontface = \"bold\")+\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100))+\n  ggtitle(\"English scores versus Maths scores for primary 3\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: ggrepel: 317 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data,\n       aes(x=MATHS,\n           y=ENGLISH))+\n  geom_point()+\n  geom_smooth(method = lm,\n              linewidth=0.5)+\n  geom_text_repel(aes(label = ID),\n                   fontface = \"bold\",\n                  size = 3.5,\n                  color = \"blue\")+\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100))+\n  ggtitle(\"English scores versus Maths scores for primary 3\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: ggrepel: 302 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"white\",\n                 fill = \"grey\")+\n  ggtitle(\"Distribution of Maths scores\")+\n  theme_wsj()+\n  theme(plot.title = element_text(size = 20))\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"white\",\n                 fill = \"grey\")+\n  ggtitle(\"Distribution of Maths scores\")+\n  theme_ipsum(axis_title_size = 15,\n              base_size = 15,\n              grid = \"N\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\np1&lt;-ggplot(data = exam_data,\n           aes(x=MATHS))+\n  geom_histogram(bins=20,\n                 boundary=100,\n                 color=\"grey25\",\n                 fill=\"grey90\")+\n  coord_cartesian(xlim=c(0,100))+\n  ggtitle(\"Distribution of Maths Scores\")\np1\n\n\n\n\n\n\n\n\n\np2&lt;-ggplot(data = exam_data,\n           aes(x=ENGLISH))+\n  geom_histogram(bins=20,\n                 boundary=100,\n                 color=\"grey25\",\n                 fill=\"grey90\")+\n  coord_cartesian(xlim=c(0,100))+\n  ggtitle(\"Distribution of English Scores\")\np2\n\n\n\n\n\n\n\n\n\np3&lt;-ggplot(data = exam_data,\n           aes(x=MATHS,\n               y=ENGLISH))+\n  geom_point()+\n  geom_smooth(method=lm,\n              size=0.5)+\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100))+\n  ggtitle(\"English scores versus Maths scores for Primary 3\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\np3\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\np1+p2\n\n\n\n\n\n\n\n\n\n\n\n\n“/” operator to stack two ggplot2 graphs\n“|” operator to place the plots beside each other\n“()” operator the define the sequence of the plotting\n\n\n(p1 / p2) | p3\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n((p1 / p2) | p3) + \n  plot_annotation(tag_levels = 'I')\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\np3 + inset_element(p2, \n                   left = 0.02, \n                   bottom = 0.7, \n                   right = 0.5, \n                   top = 1)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\npatchwork &lt;- (p1 / p2) | p3\npatchwork & theme_wsj()+theme(plot.title = element_text(size = 6))\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#data-preparation",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#data-preparation",
    "title": "Hands-on_Ex02",
    "section": "",
    "text": "pacman::p_load(ggrepel,\n               ggthemes,\n               hrbrthemes,\n               patchwork,\n               tidyverse)\n\n\n\n\n\nexam_data&lt;-read_csv(\"Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#ggrepel-to-repel-overlapping-text",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#ggrepel-to-repel-overlapping-text",
    "title": "Hands-on_Ex02",
    "section": "",
    "text": "ggplot(data=exam_data,\n       aes(x=MATHS,\n           y=ENGLISH))+\n  geom_point()+\n  geom_smooth(method = lm,\n              linewidth=0.5)+\n  geom_label(aes(label=ID),\n             hjust=.5,\n             vjust=-.5)+\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100))+\n  ggtitle(\"English scores versus Maths scores for primary 3\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data,\n       aes(x=MATHS,\n           y=ENGLISH))+\n  geom_point()+\n  geom_smooth(method = lm,\n              linewidth=0.5)+\n  geom_label_repel(aes(label = ID),\n                   fontface = \"bold\")+\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100))+\n  ggtitle(\"English scores versus Maths scores for primary 3\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: ggrepel: 317 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot(data=exam_data,\n       aes(x=MATHS,\n           y=ENGLISH))+\n  geom_point()+\n  geom_smooth(method = lm,\n              linewidth=0.5)+\n  geom_text_repel(aes(label = ID),\n                   fontface = \"bold\",\n                  size = 3.5,\n                  color = \"blue\")+\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100))+\n  ggtitle(\"English scores versus Maths scores for primary 3\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\nWarning: ggrepel: 302 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#ggthemes",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#ggthemes",
    "title": "Hands-on_Ex02",
    "section": "",
    "text": "ggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"white\",\n                 fill = \"grey\")+\n  ggtitle(\"Distribution of Maths scores\")+\n  theme_wsj()+\n  theme(plot.title = element_text(size = 20))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#hrbrthemes",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#hrbrthemes",
    "title": "Hands-on_Ex02",
    "section": "",
    "text": "ggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 boundary = 100,\n                 color = \"white\",\n                 fill = \"grey\")+\n  ggtitle(\"Distribution of Maths scores\")+\n  theme_ipsum(axis_title_size = 15,\n              base_size = 15,\n              grid = \"N\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#pathwork-to-combine-single-graphs",
    "href": "Hands-on_Ex/Hands-on_Ex02/Hands-on_Ex02.html#pathwork-to-combine-single-graphs",
    "title": "Hands-on_Ex02",
    "section": "",
    "text": "p1&lt;-ggplot(data = exam_data,\n           aes(x=MATHS))+\n  geom_histogram(bins=20,\n                 boundary=100,\n                 color=\"grey25\",\n                 fill=\"grey90\")+\n  coord_cartesian(xlim=c(0,100))+\n  ggtitle(\"Distribution of Maths Scores\")\np1\n\n\n\n\n\n\n\n\n\np2&lt;-ggplot(data = exam_data,\n           aes(x=ENGLISH))+\n  geom_histogram(bins=20,\n                 boundary=100,\n                 color=\"grey25\",\n                 fill=\"grey90\")+\n  coord_cartesian(xlim=c(0,100))+\n  ggtitle(\"Distribution of English Scores\")\np2\n\n\n\n\n\n\n\n\n\np3&lt;-ggplot(data = exam_data,\n           aes(x=MATHS,\n               y=ENGLISH))+\n  geom_point()+\n  geom_smooth(method=lm,\n              size=0.5)+\n  coord_cartesian(xlim = c(0,100),\n                  ylim = c(0,100))+\n  ggtitle(\"English scores versus Maths scores for Primary 3\")\n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\np3\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\np1+p2\n\n\n\n\n\n\n\n\n\n\n\n\n“/” operator to stack two ggplot2 graphs\n“|” operator to place the plots beside each other\n“()” operator the define the sequence of the plotting\n\n\n(p1 / p2) | p3\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n((p1 / p2) | p3) + \n  plot_annotation(tag_levels = 'I')\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\np3 + inset_element(p2, \n                   left = 0.02, \n                   bottom = 0.7, \n                   right = 0.5, \n                   top = 1)\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\npatchwork &lt;- (p1 / p2) | p3\npatchwork & theme_wsj()+theme(plot.title = element_text(size = 6))\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-1.html",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-1.html",
    "title": "Hands-on_Ex09-1",
    "section": "",
    "text": "ggtern: a ggplot extension specially designed to plot ternary diagrams. The package will be used to plot static ternary plots.\nPlotly R: an R package for creating interactive web-based graphs via plotly’s JavaScript graphing library, plotly.js . The plotly R libary contains the ggplotly function, which will convert ggplot2 figures into a Plotly object.\n\npacman::p_load(plotly, ggtern, tidyverse)\n\n\n\n\n\n\n\n#Reading the data into R environment\npop_data &lt;- read_csv(\"data/respopagsex2000to2018_tidy.csv\") \n\n\n\n\nNext, use the mutate() function of dplyr package to derive three new measures, namely: young, active, and old.\n\nagpop_mutated &lt;- pop_data %&gt;%\n  mutate(`Year` = as.character(Year))%&gt;%\n  spread(AG, Population) %&gt;%\n  mutate(YOUNG = rowSums(.[4:8]))%&gt;%\n  mutate(ACTIVE = rowSums(.[9:16]))  %&gt;%\n  mutate(OLD = rowSums(.[17:21])) %&gt;%\n  mutate(TOTAL = rowSums(.[22:24])) %&gt;%\n  filter(Year == 2018)%&gt;%\n  filter(TOTAL &gt; 0)\n\n\n\n\n\n\n\nUse ggtern() function of ggtern package to create a simple ternary plot.\n\nggtern(data=agpop_mutated,aes(x=YOUNG,y=ACTIVE, z=OLD)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nggtern(data=agpop_mutated, aes(x=YOUNG,y=ACTIVE, z=OLD)) +\n  geom_point() +\n  labs(title=\"Population structure, 2015\") +\n  theme_rgbw()\n\n\n\n\n\n\n\n\n\n\n\nTo create an interactive ternary plot using plot_ly() function of Plotly R.\n\n# reusable function for creating annotation object\nlabel &lt;- function(txt) {\n  list(\n    text = txt, \n    x = 0.1, y = 1,\n    ax = 0, ay = 0,\n    xref = \"paper\", yref = \"paper\", \n    align = \"center\",\n    font = list(family = \"serif\", size = 15, color = \"white\"),\n    bgcolor = \"#b3b3b3\", bordercolor = \"black\", borderwidth = 2\n  )\n}\n\n# reusable function for axis formatting\naxis &lt;- function(txt) {\n  list(\n    title = txt, tickformat = \".0%\", tickfont = list(size = 10)\n  )\n}\n\nternaryAxes &lt;- list(\n  aaxis = axis(\"Young\"), \n  baxis = axis(\"Active\"), \n  caxis = axis(\"Old\")\n)\n\n# Initiating a plotly visualization \nplot_ly(\n  agpop_mutated, \n  a = ~YOUNG, \n  b = ~ACTIVE, \n  c = ~OLD, \n  color = I(\"black\"), \n  type = \"scatterternary\"\n) %&gt;%\n  layout(\n    annotations = label(\"Ternary Markers\"), \n    ternary = ternaryAxes\n  )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-1.html#loading-r-packages",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-1.html#loading-r-packages",
    "title": "Hands-on_Ex09-1",
    "section": "",
    "text": "ggtern: a ggplot extension specially designed to plot ternary diagrams. The package will be used to plot static ternary plots.\nPlotly R: an R package for creating interactive web-based graphs via plotly’s JavaScript graphing library, plotly.js . The plotly R libary contains the ggplotly function, which will convert ggplot2 figures into a Plotly object.\n\npacman::p_load(plotly, ggtern, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-1.html#data-preparation",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-1.html#data-preparation",
    "title": "Hands-on_Ex09-1",
    "section": "",
    "text": "#Reading the data into R environment\npop_data &lt;- read_csv(\"data/respopagsex2000to2018_tidy.csv\") \n\n\n\n\nNext, use the mutate() function of dplyr package to derive three new measures, namely: young, active, and old.\n\nagpop_mutated &lt;- pop_data %&gt;%\n  mutate(`Year` = as.character(Year))%&gt;%\n  spread(AG, Population) %&gt;%\n  mutate(YOUNG = rowSums(.[4:8]))%&gt;%\n  mutate(ACTIVE = rowSums(.[9:16]))  %&gt;%\n  mutate(OLD = rowSums(.[17:21])) %&gt;%\n  mutate(TOTAL = rowSums(.[22:24])) %&gt;%\n  filter(Year == 2018)%&gt;%\n  filter(TOTAL &gt; 0)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-1.html#plotting-ternary-diagram-with-r",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-1.html#plotting-ternary-diagram-with-r",
    "title": "Hands-on_Ex09-1",
    "section": "",
    "text": "Use ggtern() function of ggtern package to create a simple ternary plot.\n\nggtern(data=agpop_mutated,aes(x=YOUNG,y=ACTIVE, z=OLD)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nggtern(data=agpop_mutated, aes(x=YOUNG,y=ACTIVE, z=OLD)) +\n  geom_point() +\n  labs(title=\"Population structure, 2015\") +\n  theme_rgbw()\n\n\n\n\n\n\n\n\n\n\n\nTo create an interactive ternary plot using plot_ly() function of Plotly R.\n\n# reusable function for creating annotation object\nlabel &lt;- function(txt) {\n  list(\n    text = txt, \n    x = 0.1, y = 1,\n    ax = 0, ay = 0,\n    xref = \"paper\", yref = \"paper\", \n    align = \"center\",\n    font = list(family = \"serif\", size = 15, color = \"white\"),\n    bgcolor = \"#b3b3b3\", bordercolor = \"black\", borderwidth = 2\n  )\n}\n\n# reusable function for axis formatting\naxis &lt;- function(txt) {\n  list(\n    title = txt, tickformat = \".0%\", tickfont = list(size = 10)\n  )\n}\n\nternaryAxes &lt;- list(\n  aaxis = axis(\"Young\"), \n  baxis = axis(\"Active\"), \n  caxis = axis(\"Old\")\n)\n\n# Initiating a plotly visualization \nplot_ly(\n  agpop_mutated, \n  a = ~YOUNG, \n  b = ~ACTIVE, \n  c = ~OLD, \n  color = I(\"black\"), \n  type = \"scatterternary\"\n) %&gt;%\n  layout(\n    annotations = label(\"Ternary Markers\"), \n    ternary = ternaryAxes\n  )"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html",
    "title": "Hands-on_Ex09-2",
    "section": "",
    "text": "pacman::p_load(corrplot, ggstatsplot, tidyverse)\n\n\n\n\n\nwine &lt;- read_csv(\"data/wine_quality.csv\")\n\n\n\n\n\n\n\npairs(wine[,1:11])\n\n\n\n\n\n\n\n\nThe code chunk used to create the scatterplot matrix is relatively simple. It uses the default pairs function. Columns 2 to 12 of wine dataframe is used to build the scatterplot matrix. The variables are: fixed acidity, volatile acidity, citric acid, residual sugar, chlorides, free sulfur dioxide, total sulfur dioxide, density, pH, sulphates and alcohol.\n\npairs(wine[,2:12])\n\n\n\n\n\n\n\n\n\n\n\npairs function of R Graphics provided many customisation arguments. For example, it is a common practice to show either the upper half or lower half of the correlation matrix instead of both. This is because a correlation matrix is symmetric.\nTo show the lower half of the correlation matrix, the upper.panel argument will be used as shown in the code chunk below.\n\npairs(wine[,2:12], upper.panel = NULL)\n\n\n\n\n\n\n\n\nSimilarly, you can display the upper half of the correlation matrix by using the code chun below.\n\npairs(wine[,2:12], lower.panel = NULL)\n\n\n\n\n\n\n\n\n\n\n\nTo show the correlation coefficient of each pair of variables instead of a scatter plot, panel.cor function will be used. This will also show higher correlations in a larger font.\n\npanel.cor &lt;- function(x, y, digits=2, prefix=\"\", cex.cor, ...) {\nusr &lt;- par(\"usr\")\non.exit(par(usr))\npar(usr = c(0, 1, 0, 1))\nr &lt;- abs(cor(x, y, use=\"complete.obs\"))\ntxt &lt;- format(c(r, 0.123456789), digits=digits)[1]\ntxt &lt;- paste(prefix, txt, sep=\"\")\nif(missing(cex.cor)) cex.cor &lt;- 0.8/strwidth(txt)\ntext(0.5, 0.5, txt, cex = cex.cor * (1 + r) / 2)\n}\n\npairs(wine[,2:12], \n      upper.panel = panel.cor)\n\n\n\n\n\n\n\n\n\n\n\n\nOne of the major limitation of the correlation matrix is that the scatter plots appear very cluttered when the number of observations is relatively large (i.e. more than 500 observations). To over come this problem, Corrgram data visualisation technique suggested by D. J. Murdoch and E. D. Chow (1996) and Friendly, M (2002) and will be used.\nThe are at least three R packages provide function to plot corrgram, they are: corrgram, ellipse, corrplot\nOn top that, some R package like ggstatsplot package also provides functions for building corrgram.\nIn this section, you will learn how to visualising correlation matrix by using ggcorrmat() of ggstatsplot package.\n\n\nOn of the advantage of using ggcorrmat() over many other methods to visualise a correlation matrix is it’s ability to provide a comprehensive and yet professional statistical report as shown in the figure below.\n\nggstatsplot::ggcorrmat(\n  data = wine, \n  cor.vars = 1:11)\n\n\n\n\n\n\n\n\n\nggstatsplot::ggcorrmat(\n  data = wine, \n  cor.vars = 1:11,\n  ggcorrplot.args = list(outline.color = \"black\", \n                         hc.order = TRUE,\n                         tl.cex = 10),\n  title    = \"Correlogram for wine dataset\",\n  subtitle = \"Four pairs are no significant at p &lt; 0.05\"\n)\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\ncor.vars argument is used to compute the correlation matrix needed to build the corrgram.\nggcorrplot.args argument provide additional (mostly aesthetic) arguments that will be passed to ggcorrplot::ggcorrplot function. The list should avoid any of the following arguments since they are already internally being used: corr, method, p.mat, sig.level, ggtheme, colors, lab, pch, legend.title, digits.\n\nThe sample sub-code chunk can be used to control specific component of the plot such as the font size of the x-axis, y-axis, and the statistical report.\n\nggplot.component = list(\n    theme(text=element_text(size=5),\n      axis.text.x = element_text(size = 8),\n      axis.text.y = element_text(size = 8)))\n\n\n\n\n\nSince ggstasplot is an extension of ggplot2, it also supports faceting. However the feature is not available in ggcorrmat() but in the grouped_ggcorrmat() of ggstatsplot.\n\ngrouped_ggcorrmat(\n  data = wine,\n  cor.vars = 1:11,\n  grouping.var = type,\n  type = \"robust\",\n  p.adjust.method = \"holm\",\n  plotgrid.args = list(ncol = 2),\n  ggcorrplot.args = list(outline.color = \"black\", \n                         hc.order = TRUE,\n                         tl.cex = 10),\n  annotation.args = list(\n    tag_levels = \"a\",\n    title = \"Correlogram for wine dataset\",\n    subtitle = \"The measures are: alcohol, sulphates, fixed acidity, citric acid, chlorides, residual sugar, density, free sulfur dioxide and volatile acidity\",\n    caption = \"Dataset: UCI Machine Learning Repository\"\n  )\n)\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\nto build a facet plot, the only argument needed is grouping.var.\nBehind group_ggcorrmat(), patchwork package is used to create the multiplot. plotgrid.args argument provides a list of additional arguments passed to patchwork::wrap_plots, except for guides argument which is already separately specified earlier.\nLikewise, annotation.args argument is calling plot annotation arguments of patchwork package.\n\n\n\n\n\n\nBefore we can plot a corrgram using corrplot(), we need to compute the correlation matrix of wine data frame.\nIn the code chunk below, cor() of R Stats is used to compute the correlation matrix of wine data frame.\n\nwine.cor &lt;- cor(wine[, 1:11])\n\nNext, corrplot() is used to plot the corrgram by using all the default setting as shown in the code chunk below.\n\ncorrplot(wine.cor)\n\n\n\n\n\n\n\n\nNotice that the default visual object used to plot the corrgram is circle. The default layout of the corrgram is a symmetric matrix. The default colour scheme is diverging blue-red. Blue colours are used to represent pair variables with positive correlation coefficients and red colours are used to represent pair variables with negative correlation coefficients. The intensity of the colour or also know as saturation is used to represent the strength of the correlation coefficient. Darker colours indicate relatively stronger linear relationship between the paired variables. On the other hand, lighter colours indicates relatively weaker linear relationship.\n\n\n\nIn corrplot package, there are seven visual geometrics (parameter method) can be used to encode the attribute values. They are: circle, square, ellipse, number, shade, color and pie. The default is circle. As shown in the previous section, the default visual geometric of corrplot matrix is circle. However, this default setting can be changed by using the method argument as shown in the code chunk below.\n\ncorrplot(wine.cor, \n         method = \"ellipse\") \n\n\n\n\n\n\n\n\n\n\n\ncorrplor() supports three layout types, namely: “full”, “upper” or “lower”. The default is “full” which display full matrix. The default setting can be changed by using the type argument of corrplot().\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         type=\"lower\")\n\n\n\n\n\n\n\n\nThe default layout of the corrgram can be further customised. For example, arguments diag and tl.col are used to turn off the diagonal cells and to change the axis text label colour to black colour respectively as shown in the code chunk and figure below.\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         type=\"lower\",\n         diag = FALSE,\n         tl.col = \"black\")\n\n\n\n\n\n\n\n\n\n\n\nWith corrplot package, it is possible to design corrgram with mixed visual matrix of one half and numerical matrix on the other half. In order to create a coorgram with mixed layout, the corrplot.mixed(), a wrapped function for mixed visualisation style will be used.\nFigure below shows a mixed layout corrgram plotted using wine quality data.\n\ncorrplot.mixed(wine.cor, \n               lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\n\n\n\n\n\n\n\nIn statistical analysis, we are also interested to know which pair of variables their correlation coefficients are statistically significant.\nFigure below shows a corrgram combined with the significant test. The corrgram reveals that not all correlation pairs are statistically significant. For example the correlation between total sulfur dioxide and free surfur dioxide is statistically significant at significant level of 0.1 but not the pair between total sulfur dioxide and citric acid.\nWith corrplot package, we can use the cor.mtest() to compute the p-values and confidence interval for each pair of variables.\n\nwine.sig = cor.mtest(wine.cor, conf.level= .95)\n\nWe can then use the p.mat argument of corrplot function as shown in the code chunk below.\n\ncorrplot(wine.cor,\n         method = \"number\",\n         type = \"lower\",\n         diag = FALSE,\n         tl.col = \"black\",\n         tl.srt = 45,\n         p.mat = wine.sig$p,\n         sig.level = .05)\n\n\n\n\n\n\n\n\n\n\n\nMatrix reorder is very important for mining the hiden structure and pattern in a corrgram. By default, the order of attributes of a corrgram is sorted according to the correlation matrix (i.e. “original”). The default setting can be over-write by using the order argument of corrplot(). Currently, corrplot package support four sorting methods, they are:\n“AOE” is for the angular order of the eigenvectors. See Michael Friendly (2002) for details. “FPC” for the first principal component order. “hclust” for hierarchical clustering order, and “hclust.method” for the agglomeration method to be used. “hclust.method” should be one of “ward”, “single”, “complete”, “average”, “mcquitty”, “median” or “centroid”. “alphabet” for alphabetical order. “AOE”, “FPC”, “hclust”, “alphabet”. More algorithms can be found in seriation package.\n\ncorrplot.mixed(wine.cor, \n               lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               order=\"AOE\",\n               tl.col = \"black\")\n\n\n\n\n\n\n\n\n\n\n\nIf using hclust, corrplot() can draw rectangles around the corrgram based on the results of hierarchical clustering.\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         tl.pos = \"lt\",\n         tl.col = \"black\",\n         order=\"hclust\",\n         hclust.method = \"ward.D\",\n         addrect = 3)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#installing-and-launching-r-packages",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#installing-and-launching-r-packages",
    "title": "Hands-on_Ex09-2",
    "section": "",
    "text": "pacman::p_load(corrplot, ggstatsplot, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#importing-data",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#importing-data",
    "title": "Hands-on_Ex09-2",
    "section": "",
    "text": "wine &lt;- read_csv(\"data/wine_quality.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#building-correlation-matrix-pairs-method",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#building-correlation-matrix-pairs-method",
    "title": "Hands-on_Ex09-2",
    "section": "",
    "text": "pairs(wine[,1:11])\n\n\n\n\n\n\n\n\nThe code chunk used to create the scatterplot matrix is relatively simple. It uses the default pairs function. Columns 2 to 12 of wine dataframe is used to build the scatterplot matrix. The variables are: fixed acidity, volatile acidity, citric acid, residual sugar, chlorides, free sulfur dioxide, total sulfur dioxide, density, pH, sulphates and alcohol.\n\npairs(wine[,2:12])\n\n\n\n\n\n\n\n\n\n\n\npairs function of R Graphics provided many customisation arguments. For example, it is a common practice to show either the upper half or lower half of the correlation matrix instead of both. This is because a correlation matrix is symmetric.\nTo show the lower half of the correlation matrix, the upper.panel argument will be used as shown in the code chunk below.\n\npairs(wine[,2:12], upper.panel = NULL)\n\n\n\n\n\n\n\n\nSimilarly, you can display the upper half of the correlation matrix by using the code chun below.\n\npairs(wine[,2:12], lower.panel = NULL)\n\n\n\n\n\n\n\n\n\n\n\nTo show the correlation coefficient of each pair of variables instead of a scatter plot, panel.cor function will be used. This will also show higher correlations in a larger font.\n\npanel.cor &lt;- function(x, y, digits=2, prefix=\"\", cex.cor, ...) {\nusr &lt;- par(\"usr\")\non.exit(par(usr))\npar(usr = c(0, 1, 0, 1))\nr &lt;- abs(cor(x, y, use=\"complete.obs\"))\ntxt &lt;- format(c(r, 0.123456789), digits=digits)[1]\ntxt &lt;- paste(prefix, txt, sep=\"\")\nif(missing(cex.cor)) cex.cor &lt;- 0.8/strwidth(txt)\ntext(0.5, 0.5, txt, cex = cex.cor * (1 + r) / 2)\n}\n\npairs(wine[,2:12], \n      upper.panel = panel.cor)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#visualising-correlation-matrix-ggcormat",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#visualising-correlation-matrix-ggcormat",
    "title": "Hands-on_Ex09-2",
    "section": "",
    "text": "One of the major limitation of the correlation matrix is that the scatter plots appear very cluttered when the number of observations is relatively large (i.e. more than 500 observations). To over come this problem, Corrgram data visualisation technique suggested by D. J. Murdoch and E. D. Chow (1996) and Friendly, M (2002) and will be used.\nThe are at least three R packages provide function to plot corrgram, they are: corrgram, ellipse, corrplot\nOn top that, some R package like ggstatsplot package also provides functions for building corrgram.\nIn this section, you will learn how to visualising correlation matrix by using ggcorrmat() of ggstatsplot package.\n\n\nOn of the advantage of using ggcorrmat() over many other methods to visualise a correlation matrix is it’s ability to provide a comprehensive and yet professional statistical report as shown in the figure below.\n\nggstatsplot::ggcorrmat(\n  data = wine, \n  cor.vars = 1:11)\n\n\n\n\n\n\n\n\n\nggstatsplot::ggcorrmat(\n  data = wine, \n  cor.vars = 1:11,\n  ggcorrplot.args = list(outline.color = \"black\", \n                         hc.order = TRUE,\n                         tl.cex = 10),\n  title    = \"Correlogram for wine dataset\",\n  subtitle = \"Four pairs are no significant at p &lt; 0.05\"\n)\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\ncor.vars argument is used to compute the correlation matrix needed to build the corrgram.\nggcorrplot.args argument provide additional (mostly aesthetic) arguments that will be passed to ggcorrplot::ggcorrplot function. The list should avoid any of the following arguments since they are already internally being used: corr, method, p.mat, sig.level, ggtheme, colors, lab, pch, legend.title, digits.\n\nThe sample sub-code chunk can be used to control specific component of the plot such as the font size of the x-axis, y-axis, and the statistical report.\n\nggplot.component = list(\n    theme(text=element_text(size=5),\n      axis.text.x = element_text(size = 8),\n      axis.text.y = element_text(size = 8)))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#building-multiple-plots",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#building-multiple-plots",
    "title": "Hands-on_Ex09-2",
    "section": "",
    "text": "Since ggstasplot is an extension of ggplot2, it also supports faceting. However the feature is not available in ggcorrmat() but in the grouped_ggcorrmat() of ggstatsplot.\n\ngrouped_ggcorrmat(\n  data = wine,\n  cor.vars = 1:11,\n  grouping.var = type,\n  type = \"robust\",\n  p.adjust.method = \"holm\",\n  plotgrid.args = list(ncol = 2),\n  ggcorrplot.args = list(outline.color = \"black\", \n                         hc.order = TRUE,\n                         tl.cex = 10),\n  annotation.args = list(\n    tag_levels = \"a\",\n    title = \"Correlogram for wine dataset\",\n    subtitle = \"The measures are: alcohol, sulphates, fixed acidity, citric acid, chlorides, residual sugar, density, free sulfur dioxide and volatile acidity\",\n    caption = \"Dataset: UCI Machine Learning Repository\"\n  )\n)\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above:\n\nto build a facet plot, the only argument needed is grouping.var.\nBehind group_ggcorrmat(), patchwork package is used to create the multiplot. plotgrid.args argument provides a list of additional arguments passed to patchwork::wrap_plots, except for guides argument which is already separately specified earlier.\nLikewise, annotation.args argument is calling plot annotation arguments of patchwork package."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#visualising-correlation-matrix-using-corrplot-package",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-2.html#visualising-correlation-matrix-using-corrplot-package",
    "title": "Hands-on_Ex09-2",
    "section": "",
    "text": "Before we can plot a corrgram using corrplot(), we need to compute the correlation matrix of wine data frame.\nIn the code chunk below, cor() of R Stats is used to compute the correlation matrix of wine data frame.\n\nwine.cor &lt;- cor(wine[, 1:11])\n\nNext, corrplot() is used to plot the corrgram by using all the default setting as shown in the code chunk below.\n\ncorrplot(wine.cor)\n\n\n\n\n\n\n\n\nNotice that the default visual object used to plot the corrgram is circle. The default layout of the corrgram is a symmetric matrix. The default colour scheme is diverging blue-red. Blue colours are used to represent pair variables with positive correlation coefficients and red colours are used to represent pair variables with negative correlation coefficients. The intensity of the colour or also know as saturation is used to represent the strength of the correlation coefficient. Darker colours indicate relatively stronger linear relationship between the paired variables. On the other hand, lighter colours indicates relatively weaker linear relationship.\n\n\n\nIn corrplot package, there are seven visual geometrics (parameter method) can be used to encode the attribute values. They are: circle, square, ellipse, number, shade, color and pie. The default is circle. As shown in the previous section, the default visual geometric of corrplot matrix is circle. However, this default setting can be changed by using the method argument as shown in the code chunk below.\n\ncorrplot(wine.cor, \n         method = \"ellipse\") \n\n\n\n\n\n\n\n\n\n\n\ncorrplor() supports three layout types, namely: “full”, “upper” or “lower”. The default is “full” which display full matrix. The default setting can be changed by using the type argument of corrplot().\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         type=\"lower\")\n\n\n\n\n\n\n\n\nThe default layout of the corrgram can be further customised. For example, arguments diag and tl.col are used to turn off the diagonal cells and to change the axis text label colour to black colour respectively as shown in the code chunk and figure below.\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         type=\"lower\",\n         diag = FALSE,\n         tl.col = \"black\")\n\n\n\n\n\n\n\n\n\n\n\nWith corrplot package, it is possible to design corrgram with mixed visual matrix of one half and numerical matrix on the other half. In order to create a coorgram with mixed layout, the corrplot.mixed(), a wrapped function for mixed visualisation style will be used.\nFigure below shows a mixed layout corrgram plotted using wine quality data.\n\ncorrplot.mixed(wine.cor, \n               lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               tl.col = \"black\")\n\n\n\n\n\n\n\n\n\n\n\nIn statistical analysis, we are also interested to know which pair of variables their correlation coefficients are statistically significant.\nFigure below shows a corrgram combined with the significant test. The corrgram reveals that not all correlation pairs are statistically significant. For example the correlation between total sulfur dioxide and free surfur dioxide is statistically significant at significant level of 0.1 but not the pair between total sulfur dioxide and citric acid.\nWith corrplot package, we can use the cor.mtest() to compute the p-values and confidence interval for each pair of variables.\n\nwine.sig = cor.mtest(wine.cor, conf.level= .95)\n\nWe can then use the p.mat argument of corrplot function as shown in the code chunk below.\n\ncorrplot(wine.cor,\n         method = \"number\",\n         type = \"lower\",\n         diag = FALSE,\n         tl.col = \"black\",\n         tl.srt = 45,\n         p.mat = wine.sig$p,\n         sig.level = .05)\n\n\n\n\n\n\n\n\n\n\n\nMatrix reorder is very important for mining the hiden structure and pattern in a corrgram. By default, the order of attributes of a corrgram is sorted according to the correlation matrix (i.e. “original”). The default setting can be over-write by using the order argument of corrplot(). Currently, corrplot package support four sorting methods, they are:\n“AOE” is for the angular order of the eigenvectors. See Michael Friendly (2002) for details. “FPC” for the first principal component order. “hclust” for hierarchical clustering order, and “hclust.method” for the agglomeration method to be used. “hclust.method” should be one of “ward”, “single”, “complete”, “average”, “mcquitty”, “median” or “centroid”. “alphabet” for alphabetical order. “AOE”, “FPC”, “hclust”, “alphabet”. More algorithms can be found in seriation package.\n\ncorrplot.mixed(wine.cor, \n               lower = \"ellipse\", \n               upper = \"number\",\n               tl.pos = \"lt\",\n               diag = \"l\",\n               order=\"AOE\",\n               tl.col = \"black\")\n\n\n\n\n\n\n\n\n\n\n\nIf using hclust, corrplot() can draw rectangles around the corrgram based on the results of hierarchical clustering.\n\ncorrplot(wine.cor, \n         method = \"ellipse\", \n         tl.pos = \"lt\",\n         tl.col = \"black\",\n         order=\"hclust\",\n         hclust.method = \"ward.D\",\n         addrect = 3)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html",
    "title": "Hands-on_Ex09-4",
    "section": "",
    "text": "pacman::p_load(GGally, parallelPlot, tidyverse)\n\n\n\n\n\nwh &lt;- read_csv(\"data/WHData-2018.csv\")\n\n\n\n\nIn this section, you will learn how to plot static parallel coordinates plot by using ggparcoord() of GGally package. Before getting started, it is a good practice to read the function description in detail.\n\n\nCode chunk below shows a typical syntax used to plot a basic static parallel coordinates plot by using ggparcoord().\n\nggparcoord(data = wh, \n           columns = c(7:12))\n\n\n\n\n\n\n\n\n\n\n\nThe basic parallel coordinates failed to reveal any meaning understanding of the World Happiness measures. In this section, you will learn how to makeover the plot by using a collection of arguments provided by ggparcoord().\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Parallel Coordinates Plot of World Happines Variables\")\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above.\n\ngroupColumn argument is used to group the observations (i.e. parallel lines) by using a single variable (i.e. Region) and colour the parallel coordinates lines by region name.\nscale argument is used to scale the variables in the parallel coordinate plot by using uniminmax method. The method univariately scale each variable so the minimum of the variable is zero and the maximum is one.\nalphaLines argument is used to reduce the intensity of the line colour to 0.2. The permissible value range is between 0 to 1.\nboxplot argument is used to turn on the boxplot by using logical TRUE. The default is FALSE. title argument is used to provide the parallel coordinates plot a title.\n\n\n\n\nSince ggparcoord() is developed by extending ggplot2 package, we can combination use some of the ggplot2 function when plotting a parallel coordinates plot.\nIn the code chunk below, facet_wrap() of ggplot2 is used to plot 10 small multiple parallel coordinates plots. Each plot represent one geographical region such as East Asia.\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region)\n\n\n\n\n\n\n\n\n\n\n\nTo make the x-axis text label easy to read, let us rotate the labels by 30 degrees. We can rotate axis text labels using theme() function in ggplot2 as shown in the code chunk below\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region) + \n  theme(axis.text.x = element_text(angle = 30))\n\n\n\n\n\n\n\n\nThing to learn from the code chunk above:\n\nTo rotate x-axis text labels, we use axis.text.x as argument to theme() function. And we specify element_text(angle = 30) to rotate the x-axis text by an angle 30 degree.\n\n\n\n\nRotating x-axis text labels to 30 degrees makes the label overlap with the plot and we can avoid this by adjusting the text location using hjust argument to theme’s text element with element_text(). We use axis.text.x as we want to change the look of x-axis text.\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region) + \n  theme(axis.text.x = element_text(angle = 30, hjust=1))\n\n\n\n\n\n\n\n\n\n\n\n\nparallelPlot is an R package specially designed to plot a parallel coordinates plot by using ‘htmlwidgets’ package and d3.js. In this section, you will learn how to use functions provided in parallelPlot package to build interactive parallel coordinates plot.\n\n\nThe code chunk below plot an interactive parallel coordinates plot by using parallelPlot().\n\nwh &lt;- wh %&gt;%\n  select(\"Happiness score\", c(7:12))\nparallelPlot(wh,\n             width = 320,\n             height = 250)\n\n\n\n\n\n\n\n\nIn the code chunk below, rotateTitle argument is used to avoid overlapping axis labels.\n\nparallelPlot(wh,\n             rotateTitle = TRUE)\n\n\n\n\n\n\n\n\nWe can change the default blue colour scheme by using continousCS argument as shown in the code chunl below.\n\nparallelPlot(wh,\n             continuousCS = \"YlOrRd\",\n             rotateTitle = TRUE)\n\n\n\n\n\n\n\n\nIn the code chunk below, histoVisibility argument is used to plot histogram along the axis of each variables.\n\nhistoVisibility &lt;- rep(TRUE, ncol(wh))\nparallelPlot(wh,\n             rotateTitle = TRUE,\n             histoVisibility = histoVisibility)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html#installing-and-launching-r-packages",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html#installing-and-launching-r-packages",
    "title": "Hands-on_Ex09-4",
    "section": "",
    "text": "pacman::p_load(GGally, parallelPlot, tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html#data-preparation",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html#data-preparation",
    "title": "Hands-on_Ex09-4",
    "section": "",
    "text": "wh &lt;- read_csv(\"data/WHData-2018.csv\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html#plotting-static-parallel-coordinates-plot",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html#plotting-static-parallel-coordinates-plot",
    "title": "Hands-on_Ex09-4",
    "section": "",
    "text": "In this section, you will learn how to plot static parallel coordinates plot by using ggparcoord() of GGally package. Before getting started, it is a good practice to read the function description in detail.\n\n\nCode chunk below shows a typical syntax used to plot a basic static parallel coordinates plot by using ggparcoord().\n\nggparcoord(data = wh, \n           columns = c(7:12))\n\n\n\n\n\n\n\n\n\n\n\nThe basic parallel coordinates failed to reveal any meaning understanding of the World Happiness measures. In this section, you will learn how to makeover the plot by using a collection of arguments provided by ggparcoord().\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Parallel Coordinates Plot of World Happines Variables\")\n\n\n\n\n\n\n\n\nThings to learn from the code chunk above.\n\ngroupColumn argument is used to group the observations (i.e. parallel lines) by using a single variable (i.e. Region) and colour the parallel coordinates lines by region name.\nscale argument is used to scale the variables in the parallel coordinate plot by using uniminmax method. The method univariately scale each variable so the minimum of the variable is zero and the maximum is one.\nalphaLines argument is used to reduce the intensity of the line colour to 0.2. The permissible value range is between 0 to 1.\nboxplot argument is used to turn on the boxplot by using logical TRUE. The default is FALSE. title argument is used to provide the parallel coordinates plot a title.\n\n\n\n\nSince ggparcoord() is developed by extending ggplot2 package, we can combination use some of the ggplot2 function when plotting a parallel coordinates plot.\nIn the code chunk below, facet_wrap() of ggplot2 is used to plot 10 small multiple parallel coordinates plots. Each plot represent one geographical region such as East Asia.\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region)\n\n\n\n\n\n\n\n\n\n\n\nTo make the x-axis text label easy to read, let us rotate the labels by 30 degrees. We can rotate axis text labels using theme() function in ggplot2 as shown in the code chunk below\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region) + \n  theme(axis.text.x = element_text(angle = 30))\n\n\n\n\n\n\n\n\nThing to learn from the code chunk above:\n\nTo rotate x-axis text labels, we use axis.text.x as argument to theme() function. And we specify element_text(angle = 30) to rotate the x-axis text by an angle 30 degree.\n\n\n\n\nRotating x-axis text labels to 30 degrees makes the label overlap with the plot and we can avoid this by adjusting the text location using hjust argument to theme’s text element with element_text(). We use axis.text.x as we want to change the look of x-axis text.\n\nggparcoord(data = wh, \n           columns = c(7:12), \n           groupColumn = 2,\n           scale = \"uniminmax\",\n           alphaLines = 0.2,\n           boxplot = TRUE, \n           title = \"Multiple Parallel Coordinates Plots of World Happines Variables by Region\") +\n  facet_wrap(~ Region) + \n  theme(axis.text.x = element_text(angle = 30, hjust=1))"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html#plotting-interactive-parallel-coordinates-plot-parallelplot-methods",
    "href": "Hands-on_Ex/Hands-on_Ex09/Hands-on_Ex09-4.html#plotting-interactive-parallel-coordinates-plot-parallelplot-methods",
    "title": "Hands-on_Ex09-4",
    "section": "",
    "text": "parallelPlot is an R package specially designed to plot a parallel coordinates plot by using ‘htmlwidgets’ package and d3.js. In this section, you will learn how to use functions provided in parallelPlot package to build interactive parallel coordinates plot.\n\n\nThe code chunk below plot an interactive parallel coordinates plot by using parallelPlot().\n\nwh &lt;- wh %&gt;%\n  select(\"Happiness score\", c(7:12))\nparallelPlot(wh,\n             width = 320,\n             height = 250)\n\n\n\n\n\n\n\n\nIn the code chunk below, rotateTitle argument is used to avoid overlapping axis labels.\n\nparallelPlot(wh,\n             rotateTitle = TRUE)\n\n\n\n\n\n\n\n\nWe can change the default blue colour scheme by using continousCS argument as shown in the code chunl below.\n\nparallelPlot(wh,\n             continuousCS = \"YlOrRd\",\n             rotateTitle = TRUE)\n\n\n\n\n\n\n\n\nIn the code chunk below, histoVisibility argument is used to plot histogram along the axis of each variables.\n\nhistoVisibility &lt;- rep(TRUE, ncol(wh))\nparallelPlot(wh,\n             rotateTitle = TRUE,\n             histoVisibility = histoVisibility)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#the-data",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#the-data",
    "title": "Hands-on_Ex08-2",
    "section": "The Data",
    "text": "The Data\nThe data set use for this hands-on exercise is called SGPools_svy21. The data is in csv file format.\nFigure below shows the first 15 records of SGPools_svy21.csv. It consists of seven columns. The XCOORD and YCOORD columns are the x-coordinates and y-coordinates of SingPools outlets and branches. They are in Singapore SVY21 Projected Coordinates System."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#data-import-and-preparation",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#data-import-and-preparation",
    "title": "Hands-on_Ex08-2",
    "section": "Data Import and Preparation",
    "text": "Data Import and Preparation\nThe code chunk below uses read_csv() function of readr package to import SGPools_svy21.csv into R as a tibble data frame called sgpools.\n\nsgpools &lt;- read_csv(\"data/aspatial/SGPools_svy21.csv\")\n\n\nlist(sgpools) \n\n[[1]]\n# A tibble: 306 × 7\n   NAME           ADDRESS POSTCODE XCOORD YCOORD `OUTLET TYPE` `Gp1Gp2 Winnings`\n   &lt;chr&gt;          &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;                     &lt;dbl&gt;\n 1 Livewire (Mar… 2 Bayf…    18972 30842. 29599. Branch                        5\n 2 Livewire (Res… 26 Sen…    98138 26704. 26526. Branch                       11\n 3 SportsBuzz (K… Lotus …   738078 20118. 44888. Branch                        0\n 4 SportsBuzz (P… 1 Sele…   188306 29777. 31382. Branch                       44\n 5 Prime Serango… Blk 54…   552542 32239. 39519. Branch                        0\n 6 Singapore Poo… 1A Woo…   731001 21012. 46987. Branch                        3\n 7 Singapore Poo… Blk 64…   370064 33990. 34356. Branch                       17\n 8 Singapore Poo… Blk 88…   370088 33847. 33976. Branch                       16\n 9 Singapore Poo… Blk 30…   540308 33910. 41275. Branch                       21\n10 Singapore Poo… Blk 20…   560202 29246. 38943. Branch                       25\n# ℹ 296 more rows"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#it-all-started-with-an-interactive-point-symbol-map",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#it-all-started-with-an-interactive-point-symbol-map",
    "title": "Hands-on_Ex08-2",
    "section": "It all started with an interactive point symbol map",
    "text": "It all started with an interactive point symbol map\nThe code chunks below are used to create an interactive point symbol map.\n\ntm_shape(sgpools_sf) + \n  tm_bubbles(fill = \"red\",\n           size = 1,\n           col = \"black\",\n           lwd = 1)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#lets-make-it-proportional",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#lets-make-it-proportional",
    "title": "Hands-on_Ex08-2",
    "section": "Lets make it proportional",
    "text": "Lets make it proportional\nTo draw a proportional symbol map, we need to assign a numerical variable to the size visual attribute. The code chunks below show that the variable Gp1Gp2Winnings is assigned to size visual attribute.\n\ntm_shape(sgpools_sf) + \n  tm_bubbles(fill = \"red\",\n             size = \"Gp1Gp2 Winnings\",\n             col = \"black\",\n             lwd = 1)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#lets-give-it-a-different-colour",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#lets-give-it-a-different-colour",
    "title": "Hands-on_Ex08-2",
    "section": "Lets give it a different colour",
    "text": "Lets give it a different colour\nThe proportional symbol map can be further improved by using the colour visual attribute. In the code chunks below, OUTLET_TYPE variable is used as the colour attribute variable.\n\ntm_shape(sgpools_sf) + \n  tm_bubbles(fill = \"OUTLET TYPE\", \n             size = \"Gp1Gp2 Winnings\",\n             col = \"black\",\n             lwd = 1)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#i-have-a-twin-brothers",
    "href": "Hands-on_Ex/Hands-on_Ex08/Hands-on_Ex08-2.html#i-have-a-twin-brothers",
    "title": "Hands-on_Ex08-2",
    "section": "I have a twin brothers :)",
    "text": "I have a twin brothers :)\nAn impressive and little-know feature of tmap’s view mode is that it also works with faceted plots. The argument sync in tm_facets() can be used in this case to produce multiple maps with synchronised zoom and pan settings.\n\ntm_shape(sgpools_sf) + \n  tm_bubbles(fill = \"OUTLET TYPE\", \n             size = \"Gp1Gp2 Winnings\",\n             col = \"black\",\n             lwd = 1) + \n  tm_facets(by= \"OUTLET TYPE\",\n            nrow = 1,\n            sync = TRUE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntmap_mode(\"plot\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex08/data/geospatial/MPSZ-2019.html",
    "href": "Hands-on_Ex/Hands-on_Ex08/data/geospatial/MPSZ-2019.html",
    "title": "ISSS608-VAA-Huang Zihan",
    "section": "",
    "text": "&lt;!DOCTYPE qgis PUBLIC ‘http://mrcc.com/qgis.dtd’ ‘SYSTEM’&gt;     dataset\n\n\n        0 0     false"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "The code chunk below uses p_load() of pacman package to check if tidyverse packages are installed in the laptop. If they are, then they will be launched into R.\n\npacman::p_load(tidyverse)\n\n\n\n\n\nexam_data &lt;- read_csv(\"data/Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#install-and-launching-r-packages",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#install-and-launching-r-packages",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "The code chunk below uses p_load() of pacman package to check if tidyverse packages are installed in the laptop. If they are, then they will be launched into R.\n\npacman::p_load(tidyverse)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#importing-the-data",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#importing-the-data",
    "title": "Hands-on Exercise 1",
    "section": "",
    "text": "exam_data &lt;- read_csv(\"data/Exam_data.csv\")\n\nRows: 322 Columns: 7\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (4): ID, CLASS, GENDER, RACE\ndbl (3): ENGLISH, MATHS, SCIENCE\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message."
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_bar",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_bar",
    "title": "Hands-on Exercise 1",
    "section": "Geometric Objects: geom_bar",
    "text": "Geometric Objects: geom_bar\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_bar()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_dotplot",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_dotplot",
    "title": "Hands-on Exercise 1",
    "section": "Geometric Objects: geom_dotplot",
    "text": "Geometric Objects: geom_dotplot\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_dotplot(dotsize = 0.5)\n\nBin width defaults to 1/30 of the range of the data. Pick better value with\n`binwidth`.\n\n\n\n\n\n\n\n\n\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_dotplot(binwidth = 2.5,\n               dotsize = 0.5) +\n  scale_y_continuous(NULL,\n                     breaks = NULL)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_histogram",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_histogram",
    "title": "Hands-on Exercise 1",
    "section": "Geometric Objects: geom_histogram",
    "text": "Geometric Objects: geom_histogram\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram()\n\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n\n\n\n\n\n\n\n\n\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20,\n                 color = \"white\",\n                 fill = \"light green\")\n\n\n\n\n\n\n\n\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           fill = RACE)) +\n  geom_histogram(bins = 20,\n                 color = \"grey30\")"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom-density",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom-density",
    "title": "Hands-on Exercise 1",
    "section": "Geometric Objects: geom-density",
    "text": "Geometric Objects: geom-density\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_density()\n\n\n\n\n\n\n\n\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           color = RACE)) +\n  geom_density()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_boxplot",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_boxplot",
    "title": "Hands-on Exercise 1",
    "section": "Geometric Objects: geom_boxplot",
    "text": "Geometric Objects: geom_boxplot\n\nggplot(data = exam_data,\n       aes(y = MATHS,\n           x = RACE)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\nggplot(data = exam_data,\n       aes(y = MATHS,\n           x = RACE)) +\n  geom_boxplot(notch = TRUE)\n\nNotch went outside hinges\nℹ Do you want `notch = FALSE`?\nNotch went outside hinges\nℹ Do you want `notch = FALSE`?"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_violin",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_violin",
    "title": "Hands-on Exercise 1",
    "section": "Geometric Objects: geom_violin",
    "text": "Geometric Objects: geom_violin\n\nggplot(data = exam_data,\n       aes(y = MATHS,\n           x = RACE)) +\n  geom_violin()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_point",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geometric-objects-geom_point",
    "title": "Hands-on Exercise 1",
    "section": "Geometric Objects: geom_point",
    "text": "Geometric Objects: geom_point\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           y = ENGLISH)) +\n  geom_point()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geom-objects-can-be-combined",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#geom-objects-can-be-combined",
    "title": "Hands-on Exercise 1",
    "section": "Geom Objects can be combined",
    "text": "Geom Objects can be combined\n\nggplot(data = exam_data,\n       aes(y = MATHS,\n           x = RACE)) +\n  geom_boxplot() +\n  geom_point(position = \"jitter\",\n             size = 1)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#adding-mean-value-by-using-stat_summary-and-overriding-the-default-geom",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#adding-mean-value-by-using-stat_summary-and-overriding-the-default-geom",
    "title": "Hands-on Exercise 1",
    "section": "Adding mean value by using stat_summary() and overriding the default geom",
    "text": "Adding mean value by using stat_summary() and overriding the default geom\n\nggplot(data = exam_data,\n       aes(y = MATHS,\n           x = RACE)) +\n  geom_boxplot() +\n  stat_summary(geom = \"point\",\n               fun = \"mean\",\n               color = \"light green\",\n               size = 3)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#adding-mean-value-by-using-geom_-and-overriding-the-default-stat",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#adding-mean-value-by-using-geom_-and-overriding-the-default-stat",
    "title": "Hands-on Exercise 1",
    "section": "Adding mean value by using geom_() and overriding the default stat",
    "text": "Adding mean value by using geom_() and overriding the default stat\n\nggplot(data = exam_data,\n       aes(y = MATHS,\n           x = RACE)) +\n  geom_boxplot() +\n  geom_point(stat = \"summary\",\n             fun = \"mean\",\n             color = \"light pink\",\n             size = 3)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#best-fit-curve-geom_smooth",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#best-fit-curve-geom_smooth",
    "title": "Hands-on Exercise 1",
    "section": "Best fit curve: geom_smooth()",
    "text": "Best fit curve: geom_smooth()\n\nDefault method used is loess\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           y = ENGLISH)) +\n  geom_point() +\n  geom_smooth(linewidth = 0.5)\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\nThe default smoothing method can be overridden\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           y = ENGLISH)) +\n  geom_point() +\n  geom_smooth(method = lm,\n              linewidth = 0.5)\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#facet_wrap",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#facet_wrap",
    "title": "Hands-on Exercise 1",
    "section": "facet_wrap()",
    "text": "facet_wrap()\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20) +\n    facet_wrap(~ RACE)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#facet_grid",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#facet_grid",
    "title": "Hands-on Exercise 1",
    "section": "facet_grid()",
    "text": "facet_grid()\n\nggplot(data = exam_data,\n       aes(x = MATHS)) +\n  geom_histogram(bins = 20) +\n    facet_grid(~ RACE)"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#coord_flip-to-change-the-bar-chart-from-vertical-form-to-horizontal-form",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#coord_flip-to-change-the-bar-chart-from-vertical-form-to-horizontal-form",
    "title": "Hands-on Exercise 1",
    "section": "coord_flip(): to change the bar chart from vertical form to horizontal form",
    "text": "coord_flip(): to change the bar chart from vertical form to horizontal form\n\nggplot(data = exam_data,\n       aes(x = RACE)) +\n  geom_bar() +\n  coord_flip()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#coord_cartesian-to-fix-the-axis-range",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#coord_cartesian-to-fix-the-axis-range",
    "title": "Hands-on Exercise 1",
    "section": "coord_cartesian(): to fix the axis range",
    "text": "coord_cartesian(): to fix the axis range\n\nggplot(data = exam_data,\n       aes(x = MATHS,\n           y = ENGLISH)) +\n  geom_point() +\n  geom_smooth(method = lm,\n              linewidth = 0.5) +\n  coord_cartesian(xlim = c (0,100),\n                  ylim = c (0,100))\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#theme_light",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#theme_light",
    "title": "Hands-on Exercise 1",
    "section": "theme_light()",
    "text": "theme_light()\n\nggplot(data = exam_data,\n       aes(x = RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_light()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#theme_classic",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#theme_classic",
    "title": "Hands-on Exercise 1",
    "section": "theme_classic()",
    "text": "theme_classic()\n\nggplot(data = exam_data,\n       aes(x = RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_classic()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#theme_gray",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#theme_gray",
    "title": "Hands-on Exercise 1",
    "section": "theme_gray()",
    "text": "theme_gray()\n\nggplot(data = exam_data,\n       aes(x = RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_gray()"
  },
  {
    "objectID": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#theme_minimal",
    "href": "Hands-on_Ex/Hands-on_Ex01/Hands-on_Ex01.html#theme_minimal",
    "title": "Hands-on Exercise 1",
    "section": "theme_minimal()",
    "text": "theme_minimal()\n\nggplot(data = exam_data,\n       aes(x = RACE)) +\n  geom_bar() +\n  coord_flip() +\n  theme_minimal()"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html",
    "title": "Take-home Exercise 3",
    "section": "",
    "text": "The Oceanus Music Influence Dashboard is an interactive Shiny web application designed to explore and analyze musical influences within the fictional world of Oceanus Folk music. Through a blend of network analysis, exploratory data visualization, and forecasting tools, the app offers music analysts, researchers, and enthusiasts a novel lens to uncover deep-rooted connections among artists, genres, and songs over time.\nUsers can examine the genre distribution of Oceanus Folk music, spot trends in collaborations and emerging artists, and track the evolution of significant artists like Sailor Shift within their network with this dashboard. The program provides deep insights from complex musical data in an easy-to-understand and visually appealing way by combining interactive filters, edge-node analysis, and PCA clustering."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#overview",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#overview",
    "title": "Take-home Exercise 3",
    "section": "Overview",
    "text": "Overview\nThe application is structured into three major analytical modules: Exploratory Data Analysis, Influence Network Exploration, and Rising Star Forecasting. Each module contains multiple sub-tabs that enable users to drill down into specific insights such as edge type distributions, node classifications, genre trends, influence networks, and artist projections.\nThe user journey begins with a broad exploration of data structure — understanding the relationships (edges), entities (nodes), and genre presence. Users can then move on to specialized influence networks focused on Sailor Shift and Oceanus Folk. Lastly, the application provides forward-looking visualizations to discover promising rising stars.\nA consistent layout is maintained across all tabs with sidebar selectors (year range, genre count, artist cluster) and responsive main panels that reactively update visualizations based on user input. This ensures seamless user experience and high analytical flexibility."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#image-dashboard-explanations",
    "href": "Take-home_Ex/Take-home_Ex03/Take-home_Ex03.html#image-dashboard-explanations",
    "title": "Take-home Exercise 3",
    "section": "Image Dashboard Explanations",
    "text": "Image Dashboard Explanations\n\n1. Edge and Node Type Distribution (EDA Tabs 5.1 & 5.2)\nIn the “Edge Type Count” tab, users can observe the frequency of relationship types between entities in the knowledge graph. For instance, PerformerOf is the most dominant edge type, indicating a high number of artist-to-song relationships. This allows users to infer which types of musical connections (e.g., lyrical reference, sampling, performance) are most prevalent and thus potentially more influential in shaping genre evolution.\n\n\n\nFig1. Edge Type Count\n\n\nUsers can observe the split of node types, including Person, Song, Album, and MusicalGroup, under the “Node Type Count” tab. This helps users in comprehending the makeup of the dataset and concentrating their investigation on particular entity categories, whether they are tracking individual artists, researching album-level influence, or examining label activities.\n\n\n\nFig2. Node Type Count\n\n\nUsers can interact with the year range slider to filter out nodes and edges based on release periods, which helps in isolating structural trends across time (e.g., growing presence of RecordLabel nodes in the 2020s).\n\n\n2. Genre Distribution of Songs (EDA Tab 5.3)\nThis bar chart allows users to examine the overall landscape of musical genres in the dataset. Users can place Oceanus Folk in relation to other genres by determining which genres are most represented, such as Dream Pop, Indie Folk, and Synthwave. This view can be used to evaluate niche representation, variety, and genre dominance across time by users conducting comparative genre analysis.\nTo refine this view, users can adjust the year range filter to see how genre dominance changes across time and use the Top N Genres input box to focus on the most relevant genres for their analysis.\n\n\n\nFig3. Genre Distribution of Songs\n\n\n\n\n3. Oceanus Folk Song Release Trend (Tab 5.4)\nThis time series line graph displays the number of Oceanus Folk songs released per year, offering a lens into the temporal evolution of the genre. Users can use this chart to detect creative peaks, observe genre maturation, or identify influential periods (e.g., early 2010s surge).\nUsing the year range slider, users can focus on specific historical windows (e.g., post-2015 decline or pre-2000 emergence) to contextualize Oceanus Folk’s rise and fall in relation to external events or shifts in the music scene.\n\n\n\nFig4. Oceanus Folk Song Release Trend\n\n\n\n\n4. Genres Influenced by Oceanus Folk (Tab 5.5)\nThis bar chart visualizes the top genres that were influenced by Oceanus Folk, emphasizing the genre’s downstream cultural impact. Users can use this insight to understand how Oceanus Folk has shaped other genres like Indie Folk, Synthwave, and Dream Pop.\nThe year range filter again provides the ability to explore how Oceanus Folk’s influence evolves temporally, helping users distinguish between short-term spikes and long-term influence patterns.\n\n\n\nFig5. Genres Influenced by Oceanus Folk\n\n\n\n\n5. Sailor Shift Influence Network (Sailor Shift Influence Tab)\nThis section presents two interactive network graphs. The left graph shows who influenced Sailor Shift and who she influenced, helping users track the bi-directional artistic relationships surrounding her. The right graph expands on this by showing how Sailor’s collaborators influenced or were influenced by others, uncovering broader influence pathways.\nUsers can interact with the node selection dropdown to focus on specific artists and explore sub-networks, which aids in investigating how artistic styles and collaborations have diffused through the genre network.\n\n\n\nFig6. Sailor Shift Influence Network\n\n\n\n\n6. Oceanus Folk’s Influence Over Time\nThis section helps users track the spread of Oceanus Folk’s influence over time. The line plot visualizes the number of songs influenced by Oceanus Folk per year, while the accompanying data table offers detailed metadata including song names, artist names, genres, and release years.\nUsers can apply the year range slider to examine specific decades or artistic periods. The searchable data table enables users to filter for specific genres or artists for micro-level investigation, complementing macro trends with concrete examples.\n\n\n\nFig7. Oceanus Folk’s Influence Over Time\n\n\n\n\n7. Genres That Influenced Oceanus Folk\nThis radial network graph reveals which genres contributed to shaping Oceanus Folk. It helps users analyze the genre roots of Oceanus Folk, identifying key contributors such as Jazz Surf Rock, Synthpop, or Alternative Rock.\nBelow, the influence network diagram visualizes the entire graph of influences feeding into Oceanus Folk’s evolution. The dropdown selector allows users to highlight specific nodes, facilitating focused exploration of upstream artistic and genre pathways.\n\n\n\nFig8. Genres That Influenced Oceanus Folk\n\n\n\n\n8. Rising Star Forecasting Module\nThis module provides predictive insights into future rising stars based on their genre alignment, influence connectivity, and release timelines. The timeline scatter plot maps notable artists’ upcoming releases, allowing users to assess genre engagement over time. The radar charts on the right summarize individual artist strengths across key metrics (e.g., Oceanus Folk alignment, collaborations, data stability).\nThe PCA clustering plot groups artists by shared characteristics, helping users identify distinct artist segments. Lastly, the network graph at the bottom right links rising artists to their works and collaborators, with a color-coded legend for node types.\nUsers can select specific artists or clusters to refine the analysis, making this module particularly useful for identifying under-the-radar artists or validating early-stage talent discovery.\n\n\n\nFig9. Rising Star Forecasting Module"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html",
    "title": "Take-home_Ex02",
    "section": "",
    "text": "This assignment will answer the question 2 of Mini-Challenge 1 in VAST Challenge 2025:\nDevelop visualizations that illustrate how the influence of Oceanus Folk has spread through the musical world.\n\nWas this influence intermittent or did it have a gradual rise?\nWhat genres and top artists have been most influenced by Oceanus Folk?\nOn the converse, how has Oceanus Folk changed with the rise of Sailor Shift? From which genres does it draw most of its contemporary inspiration?\n\nTo do the data visualization, we need to prepare the data first."
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#loading-packages",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#loading-packages",
    "title": "Take-home_Ex02",
    "section": "2.1 Loading Packages",
    "text": "2.1 Loading Packages\nThe following packages are the needed packages:\n\ntidyverse: A collection of R packages designed for data science, offering tools for data manipulation, visualization, and analysis using a consistent syntax.\njsonlite: Provides a robust and easy-to-use framework for parsing and generating JSON data in R.\nSmartEDA: Automates exploratory data analysis (EDA) by generating summary statistics, visualizations, and variable profiling with minimal code.\ntidygraph: Brings tidyverse principles to graph data, enabling tidy manipulation of nodes and edges in network analysis.\nggraph: An extension of ggplot2 for visualizing graph and network structures in a customizable and aesthetically pleasing way.\nplotly: Enables interactive, web-based visualizations using ggplot2 or direct plotly syntax, enhancing data exploration.\ntreemapify: Creates treemaps using the ggplot2 framework, allowing hierarchical data to be visualized with area-proportional rectangles.\nvisNetwork: Facilitates interactive network visualization using the vis.js JavaScript library, enabling dynamic manipulation and exploration of network graphs.\nRColorBrewer: An R package that provides a selection of color palettes specially designed for creating clear, visually appealing maps and graphics, particularly for categorical and sequential data.\n\n\npacman::p_load(tidyverse, jsonlite, SmartEDA, tidygraph, ggraph, plotly, treemapify, visNetwork, RColorBrewer)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#importing-data",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#importing-data",
    "title": "Take-home_Ex02",
    "section": "2.2 Importing Data",
    "text": "2.2 Importing Data\nFor the purpose of this exercise, MC1_graph.json file will be used. Before getting started, we should have the data set in the data sub-folder.\nIn the code chunk below, fromJSON() of jsonlite package is used to import MC1_graph.json file into R and save the output object\n\nkg &lt;- fromJSON(\"MC1_release/MC1_graph.json\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#extracting-the-edges-and-nodes-tables",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#extracting-the-edges-and-nodes-tables",
    "title": "Take-home_Ex02",
    "section": "2.3 Extracting the edges and nodes tables",
    "text": "2.3 Extracting the edges and nodes tables\nNext, as_tibble() of tibble package is used to extract the nodes and links tibble data frames from kg object into two separate tibble data frames called nodes_tbl and edges_tbl respectively.\n\nnodes_tbl &lt;- as_tibble(kg$nodes)\nedges_tbl &lt;- as_tibble(kg$links)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#initial-eda",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#initial-eda",
    "title": "Take-home_Ex02",
    "section": "2.4 Initial EDA",
    "text": "2.4 Initial EDA\nTo examine the data, the following code chunks are used to reveal the frequency distribution of Edge Type field of edges_tbl and the frequency distribution of Node Type field of nodes_tbl\n\nggplot(data = edges_tbl,\n       aes(y=`Edge Type`))+\n  geom_bar()\n\n\n\n\n\n\n\n\n\nggplot(data = nodes_tbl,\n       aes(y=`Node Type`))+\n  geom_bar()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#creating-knowledge-graph",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#creating-knowledge-graph",
    "title": "Take-home_Ex02",
    "section": "2.5 Creating Knowledge Graph",
    "text": "2.5 Creating Knowledge Graph\n\n2.5.1 Mapping from node id to row index\nIt is important for us to ensure each id from the node list is mapped to the correct row number, so that we can build the tidygraph.\n\nid_map &lt;- tibble (id = nodes_tbl$id,\n                  index = seq_len(\n                    nrow(nodes_tbl)))\n\n\n\n2.5.2 Tidy the Edges Table\nNext, we will map the source and the target IDs to row indices by using the code chunk below.\n\nedges_tbl &lt;- edges_tbl %&gt;%\n  left_join(id_map, by = c(\"source\" = \"id\")) %&gt;%\n  rename (from = index) %&gt;%\n  left_join(id_map, by = c(\"target\"=\"id\")) %&gt;%\n  rename(to = index)\n\n\n\n2.5.3 Filter out any unmatched (invalid) edges\nThen, the code chunk below will be used to exclude the unmatch edges.\n\nedges_tbl &lt;- edges_tbl %&gt;%\n  filter(!is.na(from),!is.na(to))\n\n\n\n2.5.4 Creating tidygraph\nLastly, tbl_graph() is used to create tidygraph’s graph object by using the code chunk below.\n\ngraph &lt;- tbl_graph(nodes = nodes_tbl,\n                 edges = edges_tbl,\n                 directed = kg$directed)\n\nTo confirm the output object is indeed in tidygraph format.\n\nclass(graph)\n\n[1] \"tbl_graph\" \"igraph\""
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#subset-relevant-songs-oceanus-folk-sailor-shift",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#subset-relevant-songs-oceanus-folk-sailor-shift",
    "title": "Take-home_Ex02",
    "section": "2.7 Subset Relevant Songs (Oceanus Folk & Sailor Shift)",
    "text": "2.7 Subset Relevant Songs (Oceanus Folk & Sailor Shift)\nIn this assignment, since we need to analyze the relationship between Oceanus Folk and Salior Shift, we prepared the data subset here.\nOceanus Folk songs:\n\nof_songs &lt;- nodes_tbl %&gt;%\n  filter(`Node Type` == \"Song\", genre == \"Oceanus Folk\")\n\nSailor Shift songs:\n\n# Get Sailor Shift's person id\nsailor_shift_id &lt;- nodes_tbl %&gt;%\n  filter(`Node Type` == \"Person\", name == \"Sailor Shift\") %&gt;%\n  pull(id)\n\n# Get All Songs Performed by Sailor Shift\nss_song_ids &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", source == sailor_shift_id) %&gt;%\n  pull(target)\n\n# Get Song Details\nsailor_shift_songs &lt;- nodes_tbl %&gt;%\n  filter(id %in% ss_song_ids, `Node Type` == \"Song\")"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#define-influence-operationally",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#define-influence-operationally",
    "title": "Take-home_Ex02",
    "section": "2.8 Define “influence” operationally",
    "text": "2.8 Define “influence” operationally\nTo illustrate how the influence of Oceanus Folk has spread through the musical world, we need to define “influence” first.\nA song is influenced by Oceanus Folk if:\n\nThe source is an Oceanus Folk song\nThe edge type is one of the below\nThe target is any other node (usually a song or album)\n\nBased on these points, we can get the influence-type edges by the following code chunk:\n\ninfluence_types &lt;- c(\"InStyleOf\", \"CoverOf\", \"LyricalReferenceTo\", \"InterpolatesFrom\", \"DirectlySamples\")\n\ninfluence_edges &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` %in% influence_types)"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#analytical-dimensions-and-visualizations",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#analytical-dimensions-and-visualizations",
    "title": "Take-home_Ex02",
    "section": "2.9 Analytical Dimensions and Visualizations",
    "text": "2.9 Analytical Dimensions and Visualizations\nTo dive into this topic, we need to understand what dimensions we will visualize, the following table is the clarification of analytical dimensions.\n\n\n\nDimension\nPurpose\n\n\n\n\nTime\nWhen influence happened\n\n\nGenre\nWhat types are influenced\n\n\nArtist\nWho are influenced\n\n\nNetwork Research\nHow influence spread structurally\n\n\nDiversity\nHow many genres/regions/styles reached"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#a.-was-this-influence-intermittent-or-did-it-have-a-gradual-rise",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#a.-was-this-influence-intermittent-or-did-it-have-a-gradual-rise",
    "title": "Take-home_Ex02",
    "section": "a. Was this influence intermittent or did it have a gradual rise?",
    "text": "a. Was this influence intermittent or did it have a gradual rise?\nFor the below code chunk, the line chart is used as the visualization, to see the influence trend based on the year. From the result, we can see the influence trend is not always rising.\nThe visualization shows that Oceanus Folk had minimal influence before the year 2000, with only sporadic instances of influenced songs. However, starting in the mid-2000s, there is a noticeable increase in influence, peaking dramatically around 2010 with more than 80 influenced songs in a single year. A second but smaller spike appears around 2017. Following that, the influence seems to decline gradually, with some fluctuations, suggesting that the genre’s impact, while still present, has become more subdued in last years.\n\ninfluence_over_time &lt;- influence_edges %&gt;%\n  filter(source %in% of_songs$id) %&gt;%\n  left_join(nodes_tbl, by = c(\"target\" = \"id\")) %&gt;%\n  filter(!is.na(release_date)) %&gt;%\n  count(release_date)\n\n# Ensure column names are friendly\ninfluence_over_time &lt;- influence_edges %&gt;%\n  filter(source %in% of_songs$id) %&gt;%\n  left_join(nodes_tbl, by = c(\"target\" = \"id\")) %&gt;%\n  filter(!is.na(release_date)) %&gt;%\n  count(release_date) %&gt;%\n  mutate(release_year = as.integer(release_date))\n\n# Create interactive plot\nplot_ly(influence_over_time,\n        x = ~release_year,\n        y = ~n,\n        type = 'scatter',\n        mode = 'lines+markers',\n        line = list(color = 'steelblue'),\n        marker = list(size = 6, color = 'black'),\n        text = ~paste(\"Year:\", release_year, \"&lt;br&gt;Influenced Songs:\", n),\n        hoverinfo = 'text') %&gt;%\n  layout(title = \"Spread of Oceanus Folk Influence Over Time\",\n         xaxis = list(title = \"Release Year of Influenced Work\"),\n         yaxis = list(title = \"Number of Influenced Songs\"),\n         hoverlabel = list(bgcolor = \"white\"))\n\n\n\n\n\nTo gain deeper insights into the spread of Oceanus Folk influence, the second chart employs a heatmap that captures the number of influenced songs by genre and release year. Each tile represents a specific genre-year combination, with darker shades indicating a higher count of influenced works. For instance, the most prominent peak occurs in 2010, where Indie Folk saw a significant surge with over 65 songs influenced by Oceanus Folk.\nThe chart also reveals that the genre’s influence is intermittent rather than continuous, as evidenced by the scattered and missing tiles across many rows and years. This suggests that Oceanus Folk’s impact varied over time and across genres, affecting some genres intensely in certain years while leaving others untouched.\n\n# Prepare heatmap data\ninfluence_heatmap &lt;- influence_edges %&gt;%\n  filter(source %in% of_songs$id) %&gt;%\n  left_join(nodes_tbl, by = c(\"target\" = \"id\")) %&gt;%\n  filter(!is.na(release_date), !is.na(genre)) %&gt;%\n  count(release_date, genre) %&gt;%\n  mutate(release_year = as.character(release_date))  # Treat as categorical for equal-width tiles\n\n# Plot\nplot_ly(influence_heatmap,\n        x = ~release_year,\n        y = ~genre,\n        z = ~n,\n        type = \"heatmap\",\n        colorscale = list(\n          c(0, \"#FFC0CB\"),\n          c(1, \"#8B0000\")\n        ),\n        text = ~paste(\"Year:\", release_year,\n                      \"&lt;br&gt;Genre:\", genre,\n                      \"&lt;br&gt;Count:\", n),\n        hoverinfo = \"text\") %&gt;%\n  layout(title = \"Oceanus Folk Influence by Year and Genre\",\n         xaxis = list(title = \"Release Year\", type = \"category\"),\n         yaxis = list(title = \"Genre\", type = \"category\"),\n         margin = list(l = 100))"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#b.-what-genres-and-top-artists-have-been-most-influenced-by-oceanus-folk",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#b.-what-genres-and-top-artists-have-been-most-influenced-by-oceanus-folk",
    "title": "Take-home_Ex02",
    "section": "b. What genres and top artists have been most influenced by Oceanus Folk?",
    "text": "b. What genres and top artists have been most influenced by Oceanus Folk?\nFollowing the line chart and heatmap analyses, which illustrated when Oceanus Folk exerted influence and which genres were affected in specific years. In this section, there are two parts, to understand what genres and top artists have been most influenced by Oceanus Folk.\n\n1. Most influenced genres by Oceanus Folk\nThe following treemap visualization offers a summarized view of the cumulative genre impact to see what genree have been most influenced by Oceanus Folk. Each rectangle represents a genre, and its area is proportional to the total number of songs influenced by Oceanus Folk within that genre.\nThe two largest segments, Oceanus Folk (117 songs) and Indie Folk (79 songs), highlight that the genre has had the strongest effect. This aligns with earlier findings where 2010 saw a major spike in Indie Folk influence. Secondary influences appear in Synthwave (10 songs), Dream Pop and Psychedelic Rock (9 each), and Desert Rock and Doom Metal, indicating that Oceanus Folk has also reached into diverse stylistic territories, albeit to a lesser extent. Meanwhile, smaller rectangles—such as those for Emo/Pop Punk, Americana, and Blues Rock—suggest more limited or niche impact.\nOverall, the treemap consolidates the previous findings into a genre-centric perspective, making it easier to see which musical styles have been most affected by Oceanus Folk’s evolving presence.\n\nof_genres &lt;- influence_edges %&gt;%\n  filter(source %in% of_songs$id) %&gt;%\n  left_join(nodes_tbl, by = c(\"target\" = \"id\")) %&gt;%\n  filter(`Node Type` == \"Song\", !is.na(genre)) %&gt;%\n  count(genre, sort = TRUE) %&gt;%\n  mutate(label_text = paste0(genre, \"\\n(\", n, \")\"))\n\nggplot(of_genres, aes(area = n, fill = genre, label = label_text)) +\n  geom_treemap() +\n  geom_treemap_text(color = \"white\", place = \"center\", size = 10, reflow = TRUE) +\n  labs(title = \"Genres Influenced by Oceanus Folk (Treemap)\") +\n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\n\n\n2. Most influenced artists by Oceanus Folk\nThis bar chart highlights the individual artists most influenced by the genre. Each bar represents an artist, with the length corresponding to the number of songs they performed that were influenced by Oceanus Folk. The chart reveals that five artists, Synaptic Stream, Stephen Meyer, Fixx’d, Chao Tan, and Alfred Thibault, are the most prominently influenced, each associated with three influenced songs. A substantial number of other artists follow closely, each contributing two influenced works.\n\n# Step 1: Get songs influenced by Oceanus Folk\nof_influenced_song_ids &lt;- influence_edges %&gt;%\n  filter(source %in% of_songs$id) %&gt;%\n  pull(target)\n\n# Step 2: Link to PerformerOf edges\ntop_artist_ids &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", target %in% of_influenced_song_ids) %&gt;%\n  count(source, sort = TRUE) %&gt;%\n  slice_max(n, n = 10)\n\n# Step 3: Get artist names\ntop_artists &lt;- top_artist_ids %&gt;%\n  left_join(nodes_tbl, by = c(\"source\" = \"id\"))\n\n# Step 4: Plot with ggplot2\nggplot(top_artists, aes(x = reorder(name, n), y = n)) +\n  geom_col(fill = \"lightcoral\") +\n  geom_text(aes(label = n), hjust = -0.2, size = 2) +\n  coord_flip() +\n  labs(title = \"Top Artists Influenced by Oceanus Folk\",\n       x = \"Artist\",\n       y = \"Number of Influenced Songs\") +\n  theme_minimal()"
  },
  {
    "objectID": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#c.-on-the-converse-how-has-oceanus-folk-changed-with-the-rise-of-sailor-shift-from-which-genres-does-it-draw-most-of-its-contemporary-inspiration",
    "href": "Take-home_Ex/Take-home_Ex02/Take-home_Ex02.html#c.-on-the-converse-how-has-oceanus-folk-changed-with-the-rise-of-sailor-shift-from-which-genres-does-it-draw-most-of-its-contemporary-inspiration",
    "title": "Take-home_Ex02",
    "section": "c. On the converse, how has Oceanus Folk changed with the rise of Sailor Shift? From which genres does it draw most of its contemporary inspiration?",
    "text": "c. On the converse, how has Oceanus Folk changed with the rise of Sailor Shift? From which genres does it draw most of its contemporary inspiration?\n\n1. Genres influence on Oceanus Folk\nThis network visualization offers a perspective on how Oceanus Folk has been influenced by other musical genres, complementing earlier analyses of how Oceanus Folk spread its influence. Each node represents a genre, and the directed edges point toward Oceanus Folk, indicating that songs from these genres have influenced the development or characteristics of Oceanus Folk songs. The central red node denotes Oceanus Folk, while the surrounding blue nodes represent the genres that contributed influence.\nNode size reflects the number of influence connections from a genre into Oceanus Folk, and color intensity highlights the top 5 most influential genres, with Desert Rock, Synthpop, and Dream Pop among the most significant. The presence of diverse genres, including Symphonic Metal, Doom Metal, Speed Metal, and Jazz Surf Rock, suggests that Oceanus Folk has drawn inspiration from a wide range of styles.\n\n# Step 1: Identify Oceanus Folk song IDs\nof_song_ids &lt;- of_songs$id  # You already have this from previous steps\n\n# Step 2: Filter influence edges where Oceanus Folk is the target\ninfluences_into_of &lt;- influence_edges %&gt;%\n  filter(target %in% of_song_ids)\n\n# Step 3: Join with nodes_tbl to get the genre of the source song\ngenre_edges &lt;- influences_into_of %&gt;%\n  left_join(nodes_tbl, by = c(\"source\" = \"id\")) %&gt;%\n  filter(`Node Type` == \"Song\", !is.na(genre)) %&gt;%\n  transmute(from = genre, to = \"Oceanus Folk\")  # genre → Oceanus Folk\n\n# Step 4: Count number of times each genre influenced Oceanus Folk\ngenre_strength &lt;- genre_edges %&gt;%\n  count(from, name = \"influence_count\")\n\n# Step 5: Identify top 5 influential genres and assign colors\ntop5_genres &lt;- genre_strength %&gt;%\n  arrange(desc(influence_count)) %&gt;%\n  slice(1:5) %&gt;%\n  mutate(color = rev(brewer.pal(5, \"Blues\")))\n\n# Step 6: Build node list with styling\ngenre_nodes &lt;- unique(c(genre_edges$from, genre_edges$to)) %&gt;%\n  tibble(id = .) %&gt;%\n  left_join(genre_strength, by = c(\"id\" = \"from\")) %&gt;%\n  left_join(top5_genres %&gt;% select(id = from, top5_color = color), by = \"id\") %&gt;%\n  mutate(\n    influence_count = replace_na(influence_count, 1),\n    label = id,\n    value = influence_count * 2,\n    color = case_when(\n      id == \"Oceanus Folk\" ~ \"#FF6347\",        \n      !is.na(top5_color) ~ top5_color,        \n      TRUE ~ \"#9ECAE1\"                         \n    ),\n    title = paste0(\"Genre: \", id, \"&lt;br&gt;Influence Count: \", influence_count)\n  )\n\n# Step 7: Draw the network\nvisNetwork(genre_nodes, genre_edges) %&gt;%\n  visEdges(arrows = \"to\") %&gt;%\n  visOptions(highlightNearest = TRUE) %&gt;%\n  visLayout(randomSeed = 123) %&gt;%\n  visPhysics(enabled = FALSE)\n\n\n\n\n\n\n\n2. Sailor Shift influence on Oceanus Folk\nTo analyze how Sailor Shift influenced Oceanus Folk, we need to explore both:\n\nDirect influence: Did any Sailor Shift songs directly influence Oceanus Folk songs?\nIndirect influence Did Sailor Shift influence intermediary songs that later influenced Oceanus Folk?\n\n\nCheck Direct influence\n\nThe following code chunk is to check if Sailor Shift has the direct influence on Oceanus Folk. However, the return result is 0, which means that there is no direct influence.\n\nof_song_ids &lt;- of_songs$id\n\nss_to_of_edges &lt;- influence_edges %&gt;%\n  filter(source %in% ss_song_ids,\n         target %in% of_song_ids)\n\nnrow(ss_to_of_edges)\n\n[1] 0\n\n\n\nCheck indirect influence\n\nThe following code chunk is to check if Sailor Shift has the indirect influence on Oceanus Folk. The return result is 2, which means there are two influence.\n\n# Step 1: Get direct influence targets from Sailor Shift's songs\nss_to_others &lt;- influence_edges %&gt;%\n  filter(source %in% ss_song_ids) %&gt;%\n  select(source_ss = source, intermediary = target)\n\n# Step 2: Get targets that influenced Oceanus Folk songs\nothers_to_of &lt;- influence_edges %&gt;%\n  filter(source %in% ss_to_others$intermediary,\n         target %in% of_song_ids) %&gt;%\n  select(intermediary = source, of_song = target)\n\n# Step 3: Join the two to find indirect influence paths\nindirect_path &lt;- ss_to_others %&gt;%\n  inner_join(others_to_of, by = \"intermediary\")\n\n# Output the number of indirect influence paths\nnrow(indirect_path)\n\n[1] 2\n\n\nIndirect Influence Visualization\nThis visualization illustrates an indirect influence path showing how Sailor Shift’s music may have shaped other works within the Oceanus Folk genre through an intermediary. Starting with “Saltwater Hymn”, a song performed by Sailor Shift and categorized under Oceanus Folk, the influence flows to “Parallel Memories”, a Dream Pop song by Tao Wen. This intermediary song then influences two other Oceanus Folk songs: “Grip and Grace” by Jun Xu and “Aquatic Rebirth (1983)” by Donald Medina.\nAlthough Sailor Shift did not directly influence these two final songs, the network reveals a two-step chain of influence, suggesting that their artistic style or thematic elements may have propagated indirectly through another genre and artist.\n\n# Step 1: Map PerformerOf edges to get artist names for songs\nsong_artists &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\") %&gt;%\n  select(song_id = target, artist_id = source) %&gt;%\n  left_join(\n    nodes_tbl %&gt;%\n      filter(`Node Type` == \"Person\") %&gt;%\n      select(artist_id = id, artist_name = name),\n    by = \"artist_id\"\n  )\n\n# Step 2: Prepare node list with genre and artist info\nindirect_nodes &lt;- nodes_tbl %&gt;%\n  filter(id %in% unique(c(indirect_path$source_ss, indirect_path$intermediary, indirect_path$of_song))) %&gt;%\n  left_join(song_artists, by = c(\"id\" = \"song_id\")) %&gt;%\n  mutate(\n    genre = ifelse(is.na(genre), \"Unknown Genre\", genre),\n    artist_name = ifelse(is.na(artist_name), \"Unknown Artist\", artist_name),\n    label = paste0(name, \"\\n\", genre, \" - \", artist_name),\n    title = paste0(\"Song: \", name, \"&lt;br&gt;Genre: \", genre, \"&lt;br&gt;Artist: \", artist_name)\n  ) %&gt;%\n  select(id, label, title) %&gt;%\n  distinct(id, .keep_all = TRUE)  # Ensure no duplicate node IDs\n\n# ✅ Step 3: Create the combined_edges object\nedges1 &lt;- indirect_path %&gt;%\n  select(from = source_ss, to = intermediary)\n\nedges2 &lt;- indirect_path %&gt;%\n  select(from = intermediary, to = of_song)\n\ncombined_edges &lt;- bind_rows(edges1, edges2)\n\n# Step 4: Visualize the network\nvisNetwork(nodes = indirect_nodes, edges = combined_edges) %&gt;%\n  visEdges(arrows = \"to\") %&gt;%\n  visOptions(highlightNearest = TRUE) %&gt;%\n  visLayout(randomSeed = 42) %&gt;%\n  visPhysics(enabled = FALSE)\n\n\n\n\n\n\nComparison before and after Sailor Shift\n\nAfter examining both the direct and indirect influence paths from Sailor Shift to specific Oceanus Folk songs, it becomes evident that Sailor Shift’s impact extended beyond individual songs to influence the broader stylistic evolution of the genre. To better understand this transformation on a macro level, we now compare the overall genre influences on Oceanus Folk before and after Sailor Shift’s emergence.\nThis visualization compares the genres that influenced Oceanus Folk songs before and after the emergence of Sailor Shift, revealing a clear shift in the genre’s stylistic development. Prior to Sailor Shift, Oceanus Folk was heavily influenced by itself, as shown by the dominant blue segment representing self-influence. The total number of influences was significantly higher in this period, indicating that Oceanus Folk initially evolved through internal reinforcement and continuity within its own style.\nAfter Sailor Shift’s emergence, the number of influences decreased, but the diversity of contributing genres increased. The influence became more distributed across a broader range of genres such as Dream Pop, Doom Metal, Darkwave, and Synthpop. This suggests that while Oceanus Folk became less self-referential in the post-Sailor Shift era.\n\nss_song_ids &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` == \"PerformerOf\", source == sailor_shift_id) %&gt;%\n  pull(target)\n\nss_release_year &lt;- nodes_tbl %&gt;%\n  filter(id %in% ss_song_ids, !is.na(release_date)) %&gt;%\n  summarise(min_year = min(as.integer(release_date))) %&gt;%\n  pull(min_year)\n\ninfluences_into_of &lt;- edges_tbl %&gt;%\n  filter(`Edge Type` %in% influence_types,\n         target %in% of_song_ids) %&gt;%\n  left_join(nodes_tbl, by = c(\"source\" = \"id\")) %&gt;%\n  filter(`Node Type` == \"Song\", !is.na(genre), !is.na(release_date)) %&gt;%\n  mutate(release_year = as.integer(release_date),\n         period = ifelse(release_year &lt; ss_release_year, \"Before SS\", \"After SS\"))\n\ninfluences_into_of %&gt;%\n  count(period, genre) %&gt;%\n  ggplot(aes(x = period, y = n, fill = genre)) +\n  geom_col(position = \"stack\") +\n  labs(title = \"Genres Influencing Oceanus Folk\\nBefore vs. After Sailor Shift\",\n       x = \"\", y = \"Number of Influences\") +\n  theme_minimal()"
  }
]